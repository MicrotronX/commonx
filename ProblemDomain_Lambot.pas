unit ProblemDomain_Lambot;
xxx xxx
//fetch stuff from scraper
//fetch stuff from bittrex


{x$DEFINE LOCAL_CACHE}
{x$DEFINE PERSIST_COMMANDS}
{$DEFINE MT_WATCH}
{$DEFINE USE_SENTINEL}


//Ichimoku cloud
//Pitchfork
//Divergences


interface

uses
  crypto_types, simplemail, tickcount, numbers, classes, debug, sharedobject, ShapeShiftDB, betterobject, storageenginetypes, typex, stringx, systemx, abstractDB, sysutils, consolelock, fft_easy, helpers.stream, MultiBufferMemoryFileStream, rdtpdb, bittrex, jsonhelpers, variants, managedthread, beeper, fiber, commandprocessor, speech, applicationparams, fleximath, commands_system, CommandIcons, orderlyinit, twitter_evil_robot, cryptocompare, rec2json, BackGroundCommandProcessor, enroyd, twitter, binance, problemdomainlambot2019;

const
CMD_ICON_WATCHER: TCommandIcon = (BitDepth: 32; RDepth:8;GDepth:8;BDepth:8;ADepth:8;Height:32;Width:32;
 data:
(
($02121313,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$01111212),
($02121313,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$03151616),
($57151616,$A8161818,$921B1D1D,$C31B1D1D,$04161717,$04161717,$04171818,$04181919,$39161717,$B71F2121,$91181A1A,$BC1B1D1D,$2B1A1C1C,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$03171818),
($5A171818,$3F1A1C1C,$04151717,$8A191B1B,$871B1D1D,$871B1D1D,$87191B1B,$86161818,$A21C1E1E,$5E161818,$04171818,$6D191B1B,$2C181919,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$03181919),
($5A171818,$61181919,$32161818,$9C1E2020,$04171818,$04181919,$04151717,$04161717,$3B171919,$7C1A1C1C,$32191A1A,$87151616,$2C161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$03151616),
($25131515,$67181A1A,$BC1C1E1E,$65171919,$04181919,$04151717,$04161717,$04161717,$1A181919,$681A1C1C,$681A1C1C,$67181A1A,$14161818,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$03151616),
($02121313,$04161717,$90181919,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$03151616),
($02121313,$04171818,$901B1C1C,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$03171818),
($02131414,$04181919,$911B1D1D,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$12171919,$4D151616,$781B1D1D,$861B1D1D,$7B191B1B,$55161818,$19171818,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$03181919),
($03161717,$04151717,$911B1D1D,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$2A1D1E1E,$89141515,$8D1E2020,$50141515,$21181A1A,$05191A1A,$1A171919,$48181919,$86181A1A,$901B1C1C,$39171919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$03151616),
($48121313,$971D1F1F,$A3191A1A,$A71B1D1D,$04181919,$04151717,$04161717,$04161717,$0C171818,$7C151717,$86202222,$16131414,$0A141616,$521D1F1F,$84181A1A,$87171919,$86191A1A,$5C191B1B,$11181919,$0E171818,$76181A1A,$8B181919,$16181A1A,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$03151616),
($5A131414,$3E161717,$04171818,$87191B1B,$04151717,$04161717,$04161717,$241A1B1B,$9E131414,$37191B1B,$04161717,$46181919,$98131515,$511D1F1F,$0D151616,$04161717,$08171818,$44181919,$941E2020,$5C181A1A,$04161717,$26181919,$A01D1F1F,$35171818,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$03151616),
($5A151616,$49181919,$12181A1A,$8C161818,$04161717,$04161717,$341C1E1E,$9C121414,$15151616,$04161717,$561A1B1B,$77101111,$06191A1A,$88141515,$8E171919,$09171818,$04171818,$04181919,$04151717,$5E191B1B,$71191A1A,$04171818,$0B161818,$90191B1B,$4B191B1B,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$03171818),
($30141515,$881B1C1C,$881B1D1D,$841A1B1B,$04161717,$351C1E1E,$97131414,$0B141515,$04161717,$27141616,$87121313,$08191A1A,$0D151616,$A2171818,$9C212323,$18191B1B,$04181919,$04151717,$04161717,$04161717,$6D181A1A,$44181919,$04151717,$05161717,$86191A1A,$4D181919,$04181919,$04151717,$04161717,$04161717,$04171818,$03181919),
($03161717,$04151717,$04161717,$04161717,$271A1C1C,$9A121313,$0A141515,$04161717,$04161717,$891C1E1E,$49202222,$9E1E2020,$9E161717,$48181A1A,$3F1A1C1C,$40191A1A,$19151616,$04161717,$04161717,$04171818,$08171919,$94191A1A,$04161717,$04161717,$05171919,$8B1C1E1E,$3D171919,$04161717,$04161717,$04171818,$04181919,$03151616),
($03131414,$04161717,$04161717,$12181919,$9D131414,$11151616,$04161717,$04161717,$08171818,$8F181A1A,$82171818,$14161818,$3B171818,$901B1D1D,$99141515,$5C1A1C1C,$8F171818,$4A191A1A,$04171818,$04181919,$04151717,$7A191B1B,$1E161717,$04171818,$04181919,$08161717,$98161717,$22181919,$04171818,$04181919,$04151717,$03151616),
($02121313,$04161717,$04171818,$8B121414,$28171919,$04161717,$04161717,$04171818,$231A1B1B,$781B1D1D,$2D191B1B,$96181A1A,$94141515,$A0181A1A,$0A141515,$04161717,$04161717,$911B1D1D,$04181919,$04151717,$04161717,$52191A1A,$48181919,$04181919,$04151717,$04161717,$16181919,$9B1D1F1F,$08171919,$04151717,$04161717,$03151616),
($02121313,$04171818,$06181919,$99191B1B,$19191A1A,$04161717,$04171818,$04181919,$25151717,$74181A1A,$04161717,$5C202222,$4A161818,$8B1A1C1C,$05161818,$04161717,$04171818,$8B151717,$04151717,$04161717,$04161717,$501B1D1D,$4B1B1D1D,$04151717,$04161717,$04161717,$0C171818,$9B121414,$0E151616,$04161717,$04161717,$03171818),
($02131414,$04181919,$04151717,$1E181A1A,$9A171818,$09171818,$04181919,$04151717,$0B161818,$8D181A1A,$04171818,$6A191B1B,$5B1D1F1F,$451A1B1B,$89181A1A,$36191B1B,$74171919,$631E2020,$04161717,$04161717,$04171818,$73191B1B,$27171919,$04161717,$04161717,$04171818,$87121414,$34191A1A,$73181919,$7A1A1C1C,$7A1B1D1D,$35151616),
($03161717,$04151717,$04161717,$04161717,$3A171919,$8D1D1F1F,$04161717,$04161717,$04161717,$8D1A1C1C,$0B171818,$04151717,$04161717,$04161717,$29161717,$661A1C1C,$36191B1B,$04161717,$04161717,$04171818,$05181A1A,$93181919,$04161717,$04161717,$04171818,$71171919,$571D1E1E,$04161717,$9A191B1B,$1F171919,$471B1D1D,$701A1C1C),
($03131414,$04161717,$04161717,$04171818,$04181919,$4C181919,$85181A1A,$05161717,$04171818,$38171818,$77181A1A,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$56121313,$59171919,$04161717,$04171818,$68191B1B,$6B1F2121,$04161717,$04161717,$8F181919,$04181919,$2F161717,$6F171919),
($02121313,$04161717,$04171818,$04181919,$04151717,$04161717,$4D181A1A,$8D1B1D1D,$0A171818,$04151717,$6F191B1B,$59181A1A,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$3E141515,$8A202222,$04161717,$05171818,$74171818,$6B1F2121,$04161717,$04161717,$04171818,$AF1D1F1F,$99181A1A,$961C1E1E,$5F141515),
($02121313,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$3A171818,$9E1A1B1B,$1F181A1A,$04161717,$65191B1B,$8A1C1E1E,$2A161717,$04161717,$04161717,$04171818,$201B1D1D,$7C121313,$7B1C1E1E,$06161717,$13181919,$90121313,$521C1E1E,$04161717,$04161717,$04171818,$04181919,$04151717,$87191B1B,$04161717,$03171818),
($02131414,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$1B191A1A,$94171818,$66191A1A,$09171818,$1B171919,$76191A1A,$8B191B1B,$87191B1B,$88171919,$811D1F1F,$26131414,$05151717,$531F2121,$9C131414,$29171919,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$871B1D1D,$04171818,$03181919),
($03161717,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$49181A1A,$98191B1B,$73191B1B,$2B181A1A,$06171919,$04181919,$04161717,$22151616,$671B1D1D,$97161818,$5F1E2020,$04151616,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$871B1D1D,$04181919,$03151616),
($03131414,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$2D161818,$73181A1A,$8F1C1E1E,$871A1B1B,$8E1D1F1F,$7A151717,$3A181A1A,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$87191B1B,$04151717,$03151616),
($02121313,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$0C171818,$59171818,$59191B1B,$5A1B1D1D,$1B151717,$04151717,$04161717,$04161717,$04171818,$55191A1A,$AF171919,$59171818,$28191A1A),
($02121313,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$1D161717,$9B191A1A,$40181919,$7B1E2020,$4A191B1B,$04161717,$04161717,$04171818,$04181919,$A71D1F1F,$40171818,$61161717,$70181919),
($02131414,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$1D161717,$7C181919,$04181919,$4F161818,$AE1E2020,$8D181A1A,$8D181919,$8E1B1D1D,$8E1B1D1D,$961B1D1D,$04161717,$30191B1B,$701B1C1C),
($03161717,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$1D191A1A,$BF1F2121,$86171818,$AA1D1F1F,$48161717,$04171818,$04181919,$04151717,$04161717,$C0181A1A,$871B1D1D,$9B171919,$6E1A1C1C),
($03131414,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$03151616),
($01111212,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616)
 ));


CMD_ICON_MANAGE: TCommandIcon = (BitDepth: 32; RDepth:8;GDepth:8;BDepth:8;ADepth:8;Height:32;Width:32;
 data:
(
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$3C000000,$A8000000,$AE000000,$4A000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$43000000,$F9000000,$FF000000,$FF000000,$FD000000,$58000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$C3000000,$FF000000,$FF000000,$FF000000,$FF000000,$DB000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$03000000,$F9000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$17000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$01000000,$F1000000,$FF000000,$FF000000,$FF000000,$FF000000,$FD000000,$0F000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$B4000000,$FF000000,$FF000000,$FF000000,$FF000000,$CC000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$47000000,$FF000000,$FF000000,$FF000000,$FF000000,$5F000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$16000000,$5A000000,$90000000,$FF000000,$FF000000,$A6000000,$54000000,$0B000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$21000000,$A6000000,$F9000000,$FF000000,$58000000,$5C000000,$70000000,$4C000000,$FF000000,$ED000000,$80000000,$0A000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$26000000,$EA000000,$FF000000,$FF000000,$FF000000,$C3000000,$6E000000,$A1000000,$AA000000,$FF000000,$FF000000,$FF000000,$C9000000,$10000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$A1000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$97000000,$AA000000,$F8000000,$FF000000,$FF000000,$FF000000,$FF000000,$8B000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$DC000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$F3000000,$F4000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$D7000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$EE000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$EE000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$C7000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$DA000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$18000000,$55000000,$20000000,$DE000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$ED000000,$34000000,$4D000000,$22000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$19000000,$06000000,$37000000,$E1000000,$FA000000,$4E000000,$1C000000,$BD000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$D0000000,$2B000000,$41000000,$F5000000,$E8000000,$42000000,$02000000,$1B000000,$02000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$07000000,$B2000000,$FF000000,$E5000000,$F6000000,$B3000000,$9F000000,$F8000000,$6B000000,$03000000,$53000000,$B6000000,$F3000000,$FF000000,$FF000000,$F7000000,$C1000000,$64000000,$07000000,$5E000000,$F4000000,$AE000000,$A4000000,$FA000000,$DA000000,$FF000000,$CE000000,$16000000,$00000000,$00000000),
($00000000,$00000000,$56000000,$FF000000,$FF000000,$FF000000,$CA000000,$03000000,$02000000,$80000000,$FA000000,$C3000000,$4D000000,$06000000,$04000000,$1D000000,$1F000000,$06000000,$04000000,$45000000,$B8000000,$FD000000,$8D000000,$05000000,$01000000,$AC000000,$FF000000,$FF000000,$FF000000,$7E000000,$00000000,$00000000),
($00000000,$00000000,$52000000,$FF000000,$FF000000,$FF000000,$AE000000,$00000000,$00000000,$00000000,$33000000,$B6000000,$FD000000,$ED000000,$B8000000,$9B000000,$9A000000,$B5000000,$E9000000,$FF000000,$C0000000,$3C000000,$00000000,$00000000,$00000000,$85000000,$FF000000,$FF000000,$FF000000,$7B000000,$00000000,$00000000),
($00000000,$00000000,$05000000,$A7000000,$FD000000,$DB000000,$2D000000,$00000000,$00000000,$00000000,$00000000,$00000000,$27000000,$72000000,$A2000000,$E2000000,$E8000000,$A4000000,$76000000,$2D000000,$00000000,$00000000,$00000000,$00000000,$00000000,$17000000,$C8000000,$FF000000,$C3000000,$12000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$0E000000,$02000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$9B000000,$AF000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$0F000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$16000000,$C6000000,$D4000000,$23000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$C2000000,$FF000000,$FF000000,$DE000000,$07000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$06000000,$FE000000,$FF000000,$FF000000,$FF000000,$27000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$B5000000,$FF000000,$FF000000,$D4000000,$04000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$0E000000,$72000000,$7B000000,$18000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000)
 ));

CMD_ICON_ROLLUP: TCommandIcon = (BitDepth: 32; RDepth:8;GDepth:8;BDepth:8;ADepth:8;Height:32;Width:32;
 data:
(
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$01FEFEFE,$4CB3B3B3,$9F606060,$CE313131,$E11E1E1E,$ED121212,$D7282828,$AD525252,$5EA1A1A1,$05FAFAFA,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$0BF4F4F4,$AE515151,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$C9363636,$1FE0E0E0,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$9A656565,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$D6292929,$15EAEAEA,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$2FD0D0D0,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$BA454545,$07F8F8F8,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$906F6F6F,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$A15E5E5E,$04FBFBFB,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$06F9F9F9,$E51A1A1A,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$AC535353,$15EAEAEA,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$4EB1B1B1,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$E8171717,$7C838383,$27D8D8D8,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$A35C5C5C,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$E11E1E1E,$B54A4A4A,$9E616161,$96696969,$926D6D6D,$44BBBBBB),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$12EDEDED,$F40B0B0B,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$F30C0C0C),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$659A9A9A,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$F30C0C0C),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$BF404040,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$C6393939),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$29D6D6D6,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$956A6A6A),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$837C7C7C,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$649B9B9B),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$04FBFBFB,$DD222222,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$34CBCBCB),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$47B8B8B8,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$F20D0D0D,$04FBFBFB),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$A25D5D5D,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$C53A3A3A,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$13ECECEC,$F40B0B0B,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$97686868,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$68979797,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$69969696,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$C53A3A3A,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$3BC4C4C4,$00FFFFFF),
($00FFFFFF,$2ED1D1D1,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$F9060606,$0BF4F4F4,$00FFFFFF),
($00FFFFFF,$89767676,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$F40B0B0B,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$D02F2F2F,$00FFFFFF,$00FFFFFF),
($06F9F9F9,$E51A1A1A,$FF000000,$FF000000,$EC131313,$827D7D7D,$35CACACA,$07F8F8F8,$00FFFFFF,$12EDEDED,$48B7B7B7,$A55A5A5A,$FD020202,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$A35C5C5C,$00FFFFFF,$00FFFFFF),
($4FB0B0B0,$FF000000,$FF000000,$CF303030,$20DFDFDF,$5AA5A5A5,$AB545454,$CD323232,$CC333333,$9C636363,$44BBBBBB,$00FFFFFF,$4CB3B3B3,$F30C0C0C,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$76898989,$00FFFFFF,$00FFFFFF),
($A9565656,$FF000000,$F40B0B0B,$27D8D8D8,$9D626262,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$A55A5A5A,$0CF3F3F3,$4EB1B1B1,$FB040404,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$49B6B6B6,$00FFFFFF,$00FFFFFF),
($EC131313,$FF000000,$A9565656,$32CDCDCD,$FF000000,$FF000000,$EC131313,$B54A4A4A,$BA454545,$F6090909,$FF000000,$FF000000,$AB545454,$00FFFFFF,$857A7A7A,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FE010101,$18E7E7E7,$00FFFFFF,$00FFFFFF),
($FF000000,$FF000000,$89767676,$47B8B8B8,$FF000000,$FF000000,$8A757575,$27D8D8D8,$00FFFFFF,$21DEDEDE,$C6393939,$FF000000,$FF000000,$42BDBDBD,$09F6F6F6,$CE313131,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$DF202020,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($E51A1A1A,$FF000000,$AC535353,$12EDEDED,$ED121212,$FF000000,$FF000000,$FF000000,$758A8A8A,$00FFFFFF,$1FE0E0E0,$FD020202,$FF000000,$8B747474,$00FFFFFF,$31CECECE,$F50A0A0A,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$B24D4D4D,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($A8575757,$FF000000,$F30C0C0C,$21DEDEDE,$42BDBDBD,$E41B1B1B,$FF000000,$FF000000,$8E717171,$00FFFFFF,$09F6F6F6,$F40B0B0B,$FF000000,$926D6D6D,$00FFFFFF,$00FFFFFF,$67989898,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$857A7A7A,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($47B8B8B8,$FF000000,$FF000000,$C6393939,$1BE4E4E4,$09F6F6F6,$48B7B7B7,$55AAAAAA,$0AF5F5F5,$05FAFAFA,$8B747474,$FF000000,$FF000000,$649B9B9B,$00FFFFFF,$00FFFFFF,$00FFFFFF,$8E717171,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$58A7A7A7,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$A6595959,$FF000000,$FF000000,$EF101010,$A15E5E5E,$7B848484,$7D828282,$9B646464,$DE212121,$FF000000,$FF000000,$DD222222,$0BF4F4F4,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$7D828282,$FB040404,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$2AD5D5D5,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$0CF3F3F3,$AB545454,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$DC232323,$2FD0D0D0,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$3FC0C0C0,$C7383838,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$FF000000,$EE111111,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF),
($00FFFFFF,$00FFFFFF,$00FFFFFF,$59A6A6A6,$BE414141,$F7080808,$FF000000,$FF000000,$F8070707,$CA353535,$78878787,$0EF1F1F1,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF,$41BEBEBE,$946B6B6B,$D02F2F2F,$F7080808,$FF000000,$FF000000,$9E616161,$00FFFFFF,$00FFFFFF,$00FFFFFF,$00FFFFFF)
 ));


CMD_ICON_PICK: TCommandIcon = (BitDepth: 32; RDepth:8;GDepth:8;BDepth:8;ADepth:8;Height:32;Width:32;
 data:
(
($02121313,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$02121313,$02121313,$02131414,$03161717,$03131414,$01111212),
($02121313,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$03151616),
($02121313,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$03171818),
($02131414,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$03181919),
($03161717,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$03151616),
($03131414,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$03151616),
($02121313,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$03151616),
($05111212,$5B1D1E1E,$66191B1B,$62161818,$5F171919,$5C191B1B,$5A1B1D1D,$57191A1A,$54161717,$52171818,$51191B1B,$511B1D1D,$50191B1B,$50161818,$52171818,$57191B1B,$691C1E1E,$8D191A1A,$83171919,$49191A1A,$06161818,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$03171818),
($35161818,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$C31C1E1E,$23161717,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$03181919),
($06151616,$98191B1B,$F81B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$DB1B1D1D,$21191B1B,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$03151616),
($03131414,$04161717,$12161717,$30171919,$431A1B1B,$5A1A1B1B,$73181A1A,$8D181919,$A8191A1A,$C41C1D1D,$DF1C1E1E,$F91B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$D4191B1B,$1E161818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$03151616),
($02121313,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$0C161717,$961D1F1F,$AA1A1C1C,$B01A1C1C,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$D31D2020,$1D161818,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$03151616),
($02121313,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$0B141616,$A71B1D1D,$FF1C1E1E,$FF1B1D1D,$D4181A1A,$6B191B1B,$FE1B1D1D,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$D2181A1A,$1E181A1A,$04171818,$04181919,$04151717,$04161717,$04161717,$03171818),
($02131414,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$541B1D1D,$FF1C1E1E,$FF1B1D1D,$F21D1F1F,$69161717,$10181A1A,$FE1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$D51C1E1E,$20161717,$04151717,$04161717,$04161717,$04171818,$03181919),
($03161717,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$13161717,$C71B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$8F1D1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$D71B1D1D,$23191B1B,$04161717,$04171818,$04181919,$03151616),
($03131414,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$0D171919,$9F191B1B,$ED1B1D1D,$B3191A1A,$9A121313,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$DB191B1B,$26161818,$04181919,$04151717,$03151616),
($02121313,$04161717,$04171818,$04181919,$04151717,$15151616,$4D191A1A,$701C1D1D,$7F191B1B,$83161818,$8A191B1B,$951C1E1E,$A31B1D1D,$B6191A1A,$DA1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$E01E2020,$31171919,$12161717,$08161717),
($02121313,$04171818,$04181919,$04161717,$82181A1A,$F51B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$53181919),
($02131414,$04181919,$04151717,$33151717,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$531B1C1C),
($03161717,$04151717,$04161717,$23191A1A,$FA1B1D1D,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FC1C1E1E,$F71B1E1E,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$531A1B1B),
($03131414,$04161717,$04161717,$04171818,$3B171919,$6A1B1D1D,$5C171919,$4D151717,$43171919,$2B1B1D1D,$08151717,$04161717,$19161717,$4E171919,$851B1C1C,$C01B1D1D,$FC1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$52171818),
($02121313,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$4B181A1A,$D11B1D1D,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$53161717),
($02121313,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$05181919,$3C181A1A,$80191A1A,$B4191B1B,$DC1A1C1C,$F91C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$FF1C1E1E,$FF1C1E1E,$FF1B1D1D,$FF1B1D1D,$FF1B1D1D,$53181919),
($02131414,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$06161818,$1C161717,$23161818,$36171919,$691A1C1C,$B71B1D1D,$FC1B1D1D,$FF1B1D1D,$FF1C1E1E,$531B1C1C),
($03161717,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$2F171818,$94191A1A,$A01B1D1D,$34181A1A),
($03131414,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$03151616),
($02121313,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$03151616),
($02121313,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$03171818),
($02131414,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$03181919),
($03161717,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$03151616),
($03131414,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$04161717,$04161717,$04171818,$04181919,$04151717,$03151616),
($01111212,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616,$03171818,$03181919,$03151616,$03151616,$03151616)
 ));

CMD_ICON_SENTINEL: TCommandIcon = (BitDepth: 32; RDepth:8;GDepth:8;BDepth:8;ADepth:8;Height:32;Width:32;
 data:
(
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$261B1A1A,$683D3C3B,$98575554,$B7656361,$C56E6B6A,$C46D6A69,$B262605F,$9052504F,$5D353433,$1A131312,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$402D2D2C,$B7706E6D,$FE878584,$FF6A6867,$FF595757,$FF535152,$FF464446,$FF474546,$FF545252,$FF5B5959,$FF6D6A6A,$F8848180,$9F5C5A59,$2B1D1C1C,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$1D181817,$A46D6B6A,$FE868483,$FF5A5859,$FF383637,$FF3D3A3B,$FF3E3B3C,$FF3E3B3D,$FF3F3C3D,$FF3D3A3C,$FF3D3B3C,$FF3D3B3C,$FF3C393A,$FF3D3B3C,$FF5E5C5C,$F6817F7D,$85535251,$0D0B0B0A,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$372B2B2A,$E5999795,$FF6A6868,$FF383637,$FF3E3B3C,$FF3E3B3C,$FF3F3D3E,$FF403D3E,$FF403D3E,$FF403D3E,$FF454243,$FF555253,$FF5B5859,$FF6D6B6B,$FF514E4F,$FF484546,$FF3E3C3D,$FF72706F,$CC817F7D,$1E171716,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$382F2E2E,$EB9B9A98,$FF545252,$FF3C393A,$FF3E3B3D,$FF403D3E,$FF3F3C3D,$FF403D3E,$FF403D3E,$FF403D3E,$FF605D5D,$FF949291,$FF807E7E,$FF8C8A89,$FFB2B0AF,$FF7F7D7C,$FFC6C4C2,$FF555353,$FF3A3739,$FF605E5E,$D4898786,$1C181717,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$1F1C1C1C,$E7A9A8A6,$FF565454,$FF3C393A,$FF3F3C3D,$FF3F3C3D,$FF494647,$FF4C4A4A,$FF4D4A4B,$FF403D3E,$FF403D3E,$FF696666,$FFB6B4B3,$FFB4B2B0,$FFC0BEBD,$FFC4C3C1,$FFB7B5B4,$FFC4C3C1,$FF5D5B5B,$FF3F3C3D,$FF3C393A,$FF656363,$C78C8A89,$090A0A0A,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$01010101,$AA8A8988,$FF737171,$FF3C393A,$FF3E3B3D,$FF403E3F,$FF989796,$FF8B8988,$FF989796,$FFA2A09F,$FF848282,$FF504D4E,$FF6C6A6A,$FF949292,$FF908F8E,$FFC9C8C6,$FFCDCCCA,$FF7F7E7E,$FFA8A6A5,$FF5E5C5C,$FF3F3C3D,$FF3E3B3D,$FF3A3739,$FF868584,$7F626160,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$48414140,$FFA6A4A4,$FF383637,$FF3E3C3D,$FF3F3C3D,$FF413E3F,$FFC4C4C2,$FFB6B5B4,$FFD0CECD,$FFB7B6B5,$FFBBBAB9,$FF5B5A5A,$FF6F6D6D,$FFC2C1C0,$FFC4C2C1,$FFD2D0CF,$FFD5D3D2,$FFCECDCC,$FFCDCCCA,$FF605E5E,$FF3F3C3D,$FF3F3C3D,$FF3E3B3C,$FF434142,$EFA7A5A4,$1E1B1B1B,$00000000,$00000000,$00000000),
($00000000,$00000000,$01010101,$C1A6A5A4,$FF636162,$FF3D3B3C,$FF403D3E,$FF3F3C3D,$FF423F40,$FFC9C8C7,$FFC1BFBF,$FFD9D8D6,$FFC0BFBE,$FFC1BFBE,$FF777675,$FF8D8C8B,$FFD6D5D4,$FFD7D6D5,$FFD9D8D7,$FFDAD9D8,$FFD9D7D6,$FFD6D5D4,$FF615F5F,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3D3A3B,$FF777575,$91777676,$00000000,$00000000,$00000000),
($00000000,$00000000,$302D2D2C,$FFBCBBBA,$FF383637,$FF3F3C3D,$FF403D3E,$FF3F3C3D,$FF423F40,$FFE3E3E1,$FFE1E1E0,$FFE0DFDE,$FFDEDDDC,$FFDDDCDB,$FFD3D2D1,$FFD7D6D5,$FFDDDCDB,$FFDEDEDC,$FFDFDEDD,$FFDEDEDC,$FFDDDCDB,$FFDCDBD9,$FF626161,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3E3B3D,$FF474546,$E9BDBCBB,$0A090908,$00000000,$00000000),
($00000000,$00000000,$74686767,$FF8A8989,$FF3C393B,$FF403D3E,$FF403D3E,$FF3F3C3D,$FF423F40,$FFE6E5E4,$FFE5E5E4,$FFE5E5E4,$FFE4E4E3,$FFE4E3E2,$FFE3E3E1,$FFE3E2E1,$FFE3E3E1,$FFE4E3E2,$FFE4E3E2,$FFE3E2E1,$FFE2E1E0,$FFE1E1DF,$FF646262,$FF3F3C3D,$FF3F3C3D,$FF3F3C3E,$FF3F3C3D,$FF3C393A,$FFA2A1A0,$4A444443,$00000000,$00000000),
($00000000,$00000000,$A5929291,$FF686667,$FF3D3B3C,$FF403D3E,$FF403D3E,$FF3F3C3D,$FF423F40,$FFEAE9E8,$FFE9E9E8,$FFEAE9E8,$FFE9E9E8,$FFE9E9E8,$FFD9D9D8,$FFE0DFDE,$FFE9E8E7,$FFE9E9E7,$FFE8E8E7,$FFE8E7E6,$FFE7E7E6,$FFE7E6E5,$FF656363,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3D3A3C,$FF828081,$7C6C6B6B,$00000000,$00000000),
($00000000,$01000000,$C7AFAEAE,$FF494749,$FF3E3B3D,$FF403D3E,$FF403D3E,$FF3F3C3D,$FF423F40,$FFEDEDEC,$FFEDEDEC,$FFEDEDEC,$FFEEEDEC,$FFEDEDEC,$FF6C6B6B,$FF8D8C8C,$FFEDEDEC,$FFEDEDEC,$FFEDECEB,$FFEDECEB,$FFECECEB,$FFECECEB,$FF666464,$FF3F3C3D,$FF3F3C3D,$FF3F3C3E,$FF3F3C3D,$FF3E3B3C,$FF6D6B6B,$9C888887,$00000000,$00000000),
($00000000,$02000000,$D9BABAB9,$FF363436,$FF3E3B3D,$FF403D3E,$FF403D3E,$FF3F3C3D,$FF423F40,$FFF1F1F0,$FFF1F1F0,$FFF1F1F0,$FFF1F1F0,$FFF1F1F0,$FF626061,$FF7A7879,$FFF1F1F0,$FFF1F1F0,$FFF1F1F0,$FFF1F1F0,$FFF1F1F0,$FFF1F1F0,$FF666565,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3E3B3D,$FF636162,$AB959594,$00000000,$00000000),
($00000000,$02000000,$D9BAB9B8,$FF373536,$FF3E3B3C,$FF403D3E,$FF403D3E,$FF3F3C3D,$FF423F40,$FFF0F0F0,$FFF1F1F0,$FFF1F1EF,$FFF1F1F0,$FFF1F1F0,$FF626161,$FF7A7878,$FFF1F1F0,$FFF0F0EF,$FFF1F1F0,$FFF1F1F0,$FFF1F1F0,$FFF0F0EF,$FF676565,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3E3B3C,$FF646162,$AB949493,$00000000,$00000000),
($00000000,$01000000,$C7ACABAB,$FF4C4A4B,$FF3E3B3D,$FF403D3E,$FF403D3E,$FF3F3C3D,$FF423F40,$FFEEEEED,$FFEEEEEC,$FFEEEEED,$FFEEEEED,$FFEFEEED,$FF626061,$FF7A7878,$FFEFEFEE,$FFEFEFEE,$FFEEEEED,$FFEEEEED,$FFEEEEED,$FFEEEEED,$FF666565,$FF3F3C3D,$FF3F3C3D,$FF3F3C3E,$FF3F3C3D,$FF3E3B3C,$FF6E6C6D,$9C858584,$00000000,$00000000),
($00000000,$00000000,$A58D8C8B,$FF6B696A,$FF3D3A3C,$FF403D3E,$FF403D3E,$FF3F3C3D,$FF423F40,$FFEAE9E8,$FFE9E9E8,$FFEAEAE8,$FFEAEAE9,$FFEBEBEA,$FF616060,$FF797777,$FFECECEB,$FFECECEB,$FFEBEBEA,$FFEAEAE9,$FFEAE9E9,$FFE9E9E8,$FF656464,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3D3A3B,$FF858383,$7B666665,$00000000,$00000000),
($00000000,$00000000,$74605F5F,$FF8E8C8D,$FF3C393B,$FF403D3E,$FF403D3E,$FF3F3C3D,$FF423F40,$FFE4E4E3,$FFE4E3E2,$FFE5E4E3,$FFE6E6E4,$FFE7E7E5,$FF615F60,$FF787576,$FFE7E7E6,$FFE8E8E7,$FFE7E7E6,$FFE6E6E5,$FFE5E5E4,$FFE4E4E3,$FF646263,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3B393A,$FFA7A5A5,$493B3A3A,$00000000,$00000000),
($00000000,$00000000,$31232322,$FEBFBEBD,$FF3A3839,$FF3F3C3D,$FF403D3E,$FF3F3C3D,$FF423F40,$FFDEDDDC,$FFDEDDDC,$FFDFDFDE,$FFE0E0DF,$FFE1E1E0,$FF605F5F,$FF767474,$FFE1E1E0,$FFE2E2E1,$FFE3E3E1,$FFE2E2E1,$FFE0E0DF,$FFDFDEDD,$FF636162,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3E3B3D,$FF4B4849,$E7B7B6B5,$0B030303,$00000000,$00000000),
($00000000,$00000000,$03000000,$C0969594,$FF696768,$FF3D3A3C,$FF403D3E,$FF3F3C3D,$FF423F40,$FFD6D6D4,$FFD7D6D5,$FFD9D8D7,$FFDBDAD9,$FFDAD9D8,$FF5F5D5D,$FF737171,$FFD9D9D7,$FFDADAD8,$FFDCDBDA,$FFDDDDDC,$FFDCDCDA,$FFDAD9D8,$FF626060,$FF3F3C3D,$FF3F3C3D,$FF3F3C3D,$FF3D3A3B,$FF7C7A7A,$906A6968,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$48313030,$FDA9A7A7,$FF3C393B,$FF3E3C3D,$FF3F3C3D,$FF423F40,$FFCFCECC,$FFCFCECD,$FFD2D1D0,$FFD2D1D0,$FFD0CFCE,$FF5C5B5B,$FF706E6E,$FFCFCECD,$FFD0D0CE,$FFD2D1D0,$FFD5D4D3,$FFD7D6D5,$FFD5D4D3,$FF605E5F,$FF3F3C3D,$FF3F3C3D,$FF3E3B3D,$FF474546,$EDA2A09F,$1F121212,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$02000000,$A8767574,$FF7C7B7B,$FF3C393A,$FF3E3B3C,$FF423F40,$FFC7C5C4,$FFC8C7C6,$FFC9C8C7,$FFC7C6C4,$FFC5C3C2,$FF595757,$FF6D6A6A,$FFC3C2C0,$FFC5C3C2,$FFC7C5C4,$FFC9C8C7,$FFCDCCCB,$FFD0CFCE,$FF5F5D5E,$FF3F3C3D,$FF3E3B3D,$FF3C3A3B,$FF8C8A8A,$7D51504F,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$21111111,$E49F9D9C,$FF5C5A5B,$FF3C393A,$FF3F3C3D,$FF5F5D5D,$FF949291,$FFA5A4A3,$FF979594,$FF676665,$FF373435,$FF696666,$FFB6B4B3,$FFB7B5B4,$FFBAB8B6,$FFBDBBBA,$FFC1BFBE,$FFC5C4C3,$FF5D5B5B,$FF3F3C3D,$FF3C393A,$FF6D6B6B,$C47C7A79,$09010101,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$3A1F1E1E,$E8949291,$FF5B595A,$FF3C393A,$FF3E3B3C,$FF3E3B3C,$FF393738,$FF3B3839,$FF3F3C3D,$FF403D3E,$FF524F50,$FF939190,$FFA8A6A4,$FFAAA8A6,$FFAEACAA,$FFB3B1AF,$FF989795,$FF454343,$FF3C393B,$FF696667,$D17F7D7B,$1D0C0C0C,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$381B1B1A,$E18C8A88,$FF716F6F,$FF3F3C3E,$FF3E3B3C,$FF3E3B3C,$FF3F3C3D,$FF403D3E,$FF403D3E,$FF403D3E,$FF3A3839,$FF504E4E,$FF605E5D,$FF5F5D5D,$FF494748,$FF343233,$FF434142,$FF7B7878,$C86E6C6A,$1E0C0C0B,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$1E0B0B0A,$A4595756,$FA868483,$FF605D5E,$FF403D3F,$FF3C3A3B,$FF3E3B3C,$FF3E3B3D,$FF3E3B3D,$FF3D3A3B,$FF3D3A3C,$FF3D3A3C,$FF3B393A,$FF454243,$FF646262,$F17D7B7A,$8641403F,$0C010101,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$01000000,$40191918,$B55B5958,$F7858382,$FF716F6F,$FF5F5D5D,$FF555253,$FF514E4F,$FF504E4F,$FF555354,$FF625F5F,$FF747170,$F07E7B7A,$A04B4948,$2B0E0E0E,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$02000000,$26090909,$6A2E2D2C,$99474544,$B8575553,$C55C5A59,$C45C5A58,$B3535150,$9141403F,$5D272625,$19040404,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000),
($00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000)
 ));



const
  //BOTTOM_RANKS = 250;
  TOP_RANKS = 999;

  DEFAULT_TYPICAL_OPEN_TRADES = 8;
  WALL_SLIPPAGE_TEST_SIZE = 5;
  DAY_WINDOW_PERIODS_TIGHT = 4;
  DAY_WINDOW_PERIODS_ALLIN = 1;
  ORDERBOOK_BALANCE_DIV = 8;
  BUY_MIN_SPREAD = 0.002;


  CROSSBUMP_THRES = 0.09;
  MAX_CHECKPOINTS = 11;
  INVALID_CURRENCY_ID = -1;
  QUOTE_WINDOW = 60;

  MAX_OPEN_TRADES = 75;
  FUND_RISK_DIVISOR = 1;
  SWING_TAKE_DIV = 4;
  SWING_DROP_DIV = 4;

type
  TCoinSlope = record
    nao: double;
    future: double;
    time: double;
    function PercentRise: double;
  end;


  TStrategy = class;//forward
  TMarketScore = record
  private
    procedure SetMessage(Value: string);
  public
    coin: string;
    j: IHolder<TJSON>;
    Fmsg: string;
    delist: boolean;
    banned: boolean;
    score: double;
    checkpoints: ni;
    passed: ni;
    rank: ni;
    bottomrank: ni;
    anal: TChartAnalysis;
    scantime: ticker;
    procedure Init;
    property Msg: string read FMsg write SetMessage;
    function RefreshRate: ni;
  end;
  PMarketScore = ^TMarketScore;

  TDomainMessage = record
    typ: string;
    param: string;
  end;

  TShapeShiftDomain = class(TSharedObject)
  strict
  private
    accountid: int64;
    FSimulated: boolean;
    procedure SetSimulated(const Value: boolean); protected

  public
    ssdb: TShapeShiftDB;
    btx: TBTXclient;
    bin: TBinanceclient;
    property simulated: boolean read FSimulated write SetSimulated;
    procedure Init;override;
    procedure Detach;override;
    procedure DispatchMessage(m: TDomainMessage);virtual;
  end;

  TPDHoldings = class(TShapeShiftDomain)
  private
    rs: TSERowSet;//ok
    function GetCurrencies(idx: ni): string;
    function GEtHoldings(cc: string): double;
  public

    procedure Refresh(maxsampleid: int64 = -1);
    procedure Detach; override;
    property holdings[cc: string]: double read GEtHoldings;
    property currencies[idx: ni]: string read GetCurrencies;
    function Count: ni;
  end;

  TPDcurrencies = class(TShapeShiftDomain)
  public
    rsCurrencies: TSERowSet;//ok
    procedure Refresh(OnlyTradable: boolean = false; AILive: boolean = false; AISim: boolean = false);
    function NameToCC(sName: string): string;
    function CCToName(sCurrencyCode: string): string;
    function CCToID(sCurrencyCode: string): int64;
    procedure Detach; override;

  end;

  TPDTrades = class(TShapeShiftDomain)
  private
    FAllowTrades: boolean;
    FallowDBUpdates: boolean;
    function GetTradecount: ni;
    procedure SortMarketScores;
    function IsCryptopiaMarket(sCoin: string): boolean;
    function GetMarketComparison(sCoin: string): PMarketComparison;
  public
    rsOpenTrades: TSErowSet;//ok
    trades: array of TOpenPosition;
    marketComparisons: TArray<TMarketComparison>;
    previousMarketScores: TArray<TMarketScore>;
    marketScores: Tarray<TMarketScore>;
    lastWatchPickTime: ticker;
    lastTradePickTime: ticker;
    btcmoon: boolean;
    cmc: TArray<TCMCRecord>;
    cryptCompare: TCryptCompare;
    closedPositions: TArray<TClosedPosition>;
    fundValue: double;
    watching: TArray<TMarketScore>;
    moons: ni;
    bags: ni;
    closed: ni;
    crypt: TArray<TMarketComparison>;
    dropBags: boolean;
    climateAssessment: double;
    bitcoinClimate: double;
    lastClimateAssessment: ticker;
    allowNewPositions: boolean;
    strat: TStrategy;

    function IsDuplicatePosition(p: TOpenPosition; stateLow: ni = 0; stateHigh: ni = 0): boolean;
    function LoadSignalBuckets(sBase, sMarket: string): TBuckets;
    function UpdateClimateAssessment: double;
    procedure ClearWatching;
    procedure WatchCoin(ms: TMarketScore);
    procedure UpdateFundValue;
    procedure Fetch;
    procedure Save;

    procedure SavePosition(p: TOpenPosition);
    procedure DispatchMessage(m: TDomainMessage); override;
    procedure Init; override;
    constructor Create; override;
    destructor Destroy; override;

    property TradeCount: ni read GetTradecount;
    function IsAlreadyWatching(sBase, sCoin: string): boolean;
    function CreatePosition(ex, sBase, sCoin: string; amountToSpend: double; maxrate: double; strategy: double; jsCreate: string): string;
    function GetTradeByUUID(sUUID: string): TOpenPosition;
    function CheckPositions(liquidate: boolean; thr: TManagedThread): boolean;
    procedure PickTrades;
    function TYPICAL_OPEN_TRADES: double;
    function TimeToPickTrade: boolean;
    function TimeToPickWatch: boolean;
    procedure PickToScanXX;
    procedure PickToScan;
    procedure PickToScan_Arb;
    procedure RollUpTrajectories(c: TCommand);
    procedure RollUpTrajectory(sBase, sMarketCoin: string);
    function GetAverageMarketHighsFreq: TMarketFrequency;
    function GetAverageMarketLowsFreq: TMarketFrequency;

    function FindMarketScore(coin: string): PMarketScore;
    function FindPrevMarketScore(coin: string): PMarketScore;
    function FindOpenPosition(sCoin: string; iWindowSize: ni): POpenPosition;overload;
    function FindOpenPosition(id: int64): PopenPosition;overload;

    procedure BeginOpenPosition(p: POpenPosition; frommarket: string = 'USDT'; forceRate: double = 0.0);
    procedure BeginClosePosition(p: POpenPOsition; tomarket: string = 'BTC');
    procedure ForceClose(id: int64);

    procedure SendSellMail(p: TOpenPosition);
    property AllowDBupdates: boolean read FallowDBUpdates write FAllowDBUpdates;
    property AllowTrades: boolean read FAllowTrades write FAllowTrades;
    procedure MarketUpdated(ms: TMarketScore);
    procedure AddMarketScore(ms: TMarketScore);
    procedure LiquidateDust;
    procedure RollUpSignals(fm: TFlexiMath; id: int64; ts: TDateTime; cBase, cMarket: string);
    procedure RollUpSignalBatch;
    procedure CleanStats(upto: int64);
    function FindRecentPositionTime(sBase, sMarket: string; istrategy: ni): TDateTime;
    procedure RefreshCMCCoins;
    function GetCMCCoin(sCoin: string): TCMCRecord;
    function AllowedToSell(sCoin: string): boolean;
    function GetOrderBookAction(sBase, sAlt: string; bt: TBookType): double;overload;
    function GetOrderBookAction(sBase, sAlt: string): double;overload;
    function GetOrderBookActionBalance(sBase, sAlt: string): double;
    procedure FindAndPushTweets(sCoin: string);
    procedure Tweet(msg: string);
    procedure FollowCoin(coin: string; twitterhandle: string);
    procedure RefreshClosedPositions;
    procedure ChartToStats(ex: string; c: TChartAnalysis; behind: boolean);
    function GetChartRange(ex, cbase, cmarket: string; period: TChartPeriod; dtstart, dtend: TDateTime): TArray<TchartRec>;
    procedure PushTradeRecommendationsToWeb;
    procedure PushTopSocialToWeb;
    procedure PromoteOpenTrades;
    procedure FixSocialVelocity(coin: string);
    procedure TryFixSocialVelocity(coin: string);
    function GetAndPushChartData(ex: string; cBase, cMarket: string; period: TChartPeriod): TArray<TChartRec>;
  end;

  Tcmd_ChartToStats = class(TCommand)
  public
    exchange: string;
    cd: TArray<TChartRec>;
    procedure DoExecute; override;
    procedure InitExpense; override;
  end;


  Tcmd_GetChartAndPush = class(TCommand)
  public
    basecoin, marketcoin: string;
    period: TChartPeriod;
    calcPeriods: ni;
    procedure DoExecute; override;
    procedure InitExpense; override;

  end;




  TQuoteItem = record
    sampleid: int64;
    cid: int64;
    rate: double;
    avgHour: double;
    avgDay: double;
    avgWeek: double;
    avgHour_Latent: double;
    avgDay_Latent: double;
    avgWeek_Latent: double;
    minerfee: double;
    volumeBuy15: double;
    volumeSell15: double;
    volumeNet15: double;
    volumeBuy30: double;
    volumeSell30: double;
    volumeNet30: double;
    volumeBuy60: double;
    volumeSell60: double;
    volumeNet60: double;
    volumeBuy240: double;
    volumeSell240: double;
    volumeNet240: double;
    volumeBuyDay: double;
    volumeSellDay: double;
    volumeNetDay: double;
    procedure SavetoStream(s: TStream);



    procedure LoadFromStream(s: TStream);
  end;

  TPDQuotes = class(TShapeShiftDomain)
  strict private
    rs,rsq: TSERowSet;
    real_qs: array of TQuoteItem;
    fake_qs: array of TQuoteItem;
    FUnifiedCount: ni;
    FFogLimit: int64;
    FFutureLimit: int64;
    FccFrom: string;
    FccTo: string;
    function GetItem(idx: ni): TQuoteItem;
    procedure RollUp;
    function GetExtrapolatedQuote(idx: ni): TQuoteItem;
    function GetUnifiedArray(idx: ni): TQuoteItem;//ok
    procedure SetUnifiedArray(idx: ni; const Value: TQuoteItem);//ok
    function GetUnifiedCount: ni;
    procedure SetUnifiedCount(const Value: ni);
    property UnifiedArray[idx: ni]: TQuoteItem read GetUnifiedArray write SetUnifiedArray;
    property UnifiedCount: ni read GetUnifiedCount;
  private
    FDataStart: int64;
    highestKnownSampleID: int64;
    procedure FabricateMissingPieces;
    procedure LoadFromCache;
    procedure SavetoCache;
    function CacheFile: string;
  public

    procedure Detach;override;
    procedure Refresh(cFrom, cTo: string; iSampleIDLimit: int64 = -1;iSampleIDStart: int64 = 0);
    function RealCount: ni;
    function UsableCount: ni;

    //KEY
    property QuotePool[idx: ni]: TQuoteItem read GetItem;
    property RealQuotes[idx: ni]: TQuoteItem read GetItem;
    property Extrapolatedquotes[idx: ni]: TQuoteItem read GetExtrapolatedQuote;
    property UnifiedQuotes[idx: ni]:TQuoteItem read GetUnifiedArray;

    property DataStart: int64 read FDataStart write FDataStart;
    property FogLimit: int64 read FFogLimit write FFogLimit;
    property FutureLimit: int64 read FFutureLimit write FFutureLimit;
    property ccFrom: string read FccFrom write FccFrom;
    property ccTo: string read FccTo write FccTo;


    function GetVolatility(samplesize: int64; iSampleIDMax: int64 = -1): double;
    function GetHigh(samplesize: int64; iSampleIDMax: int64 = -1): double;
    function GetLow(samplesize: int64; iSampleIDMax: int64 = -1): double;
    function GetFutureHigh(samplesize: int64; iSampleIDMax: int64 = -1): double;
    function GetFutureLow(samplesize: int64; iSampleIDMax: int64 = -1): double;

    function GetFrequency(samplesize: int64; zerocrossSampleSize: int64; iSampleIDMax: int64 = -1): double;
    function GEtAmplitude(samplesize: int64; zerocrossSampleSize: int64; iSampleIDMax: int64 = -1): double;
    function AveragePeriod(samplesize: int64; zerosamplesize:int64; iSampleIDMax: int64 = -1): double;
    function GetAverage(endidx: int64; samplesize: int64;bLatent: boolean): double;
    function IndexOfSampleid(sampleid: int64): ni;
    function AdjustSampleID(sampleid: int64): int64;
    function GetValueInUSD(ccIn: string; inValue: double; sampleid: int64 = -1): double;
    procedure DownloadToCache(cTo: string; upToSampleID: int64);
    procedure LoadQuotesFromCache(cFrom, cTo: string; iSampleIDLimit: int64 = -1;iSampleIDStart: int64 = 0);
    function GetMaxSampleIDInCache: int64;
    function QuoteCacheFile(cc: string): string;
    function ExtrapolatedCount: ni;


  end;

  TopenPOsitionArray = array of TOpenPosition;


  Tcmd_RollupTrajectories = class(TCommand)
  protected
    pd: TProblemDomainLambot2019;xxx
  public
    procedure Init; override;
    procedure Detach; override;

    procedure DoExecute; override;

  end;

  TMarketSentinel = class(TCommand)
  protected
    pd: TPDTrades;
    cmd_traj: Tcmd_RollUpTrajectories;
    procedure DoExecute; override;
    procedure Init; override;
    procedure Detach; override;
  public
    PickNewToWatch: boolean;
    procedure GivePreviousResults(a: TArray<TMarketScore>; w: TArray<TMarketScore>);
    function GetResults(var a: TArray<TMarketScore>; var w: TArray<TMarketScore>): boolean;
  end;



  TBittrexWatcher = class(TManagedThread)
  protected
    marketsUpdated: boolean;
    PositionsUpdated: boolean;
    lastValueCheck: ticker;
    cmd: TMarketSentinel;
    timeSinceLastSentinel: ticker;
    procedure DoExecute; override;
    procedure OnFinish; override;
  public
    fundValue: double;
    aPositionChanged: boolean;
    pdTrades: TPDTrades;//[]
    liquidateToBTC: boolean;
    lastWebPush: ticker;
    procedure Init; override;
    procedure Detach; override;
    function GetUpdatedPositions(var a: TopenPositionArray): boolean;
    function GetUpdatedWatchers(var a: TArray<TMarketScore>): boolean;
    function GetUpdatedMarketScores(var a: TArray<TMarketScore>): boolean;

  end;

  TForcedPosition = record
    base: string;
    market: string;
    risk: double;
    enable: boolean;
    procedure init;
  end;

  TStrategy = class(TBetterObject)
  public
    pdTrades: TPDTrades;
    forcedPosition: TForcedPosition;

    procedure PickTrades;virtual;abstract;
    function ManageTrades(Liquidate: boolean; thr: TManagedThread): boolean;virtual;abstract;
  end;





  TStrategyCommand = class(TCommand)
  protected
    pdTrades: TPDTrades;
    fm: TFlexiMath;
  public
    Liquidate: boolean;

    //strat: TTypicalStrategy;
    procedure Init; override;
    procedure Detach; override;
    procedure New;
    procedure DoExecute; override;
    procedure StratStatus(s: string);virtual;
  end;


  TPickInputs = record
    toSpend: double;
  end;

  TManageStrategy = class(TStrategyCommand)
  public
    p: TOpenPosition;
    FundValue: double;
    procedure DoExecute;override;
    procedure InitExpense;override;
    procedure Init;override;
    procedure StratStatus(s: string);override;
  end;

  TPickStrategy = class(TStrategyCommand)
  public
    ms: TMarketScore;
    pi: TPickInputs;
    riskSize: double;
    procedure DoExecute;override;
    procedure Init;override;
    procedure InitExpense;override;
    procedure StratStatus(s: string);override;
  end;




//  TChartProvider = class(TSharedObject)
//  public
//    function ProvideChartData(btx: TBTXclient; db: TShapeShiftDB; cBase, cMarket: string; per: TChartPeriod): string;
//  end;






procedure CoinMail(sMsg: string; sTO: string = '');

var
  cacheLocks: TNamedRWLocks;
  shutdown: boolean = false;
  GAllowNewPositions: boolean = true;
  ManageProcesssor: commandprocessor.TCommandProcessor;
  GJSONCache: TJSONCache;
  GDebugPositionID: int64;



implementation


uses
  TypicalStrategy, Strategy_TUSD_USDT;


procedure CoinMail(sMsg: string; sTO: string = '');
var
  s1,s2: string;
  adminmail: string;
begin
  ADMINMAIL := APGet('EMAIL', '');

  if sTO = '' then
    sTO := ADMINMAIL;
  if adminmail = '' then
    exit;


  SendMail('bot@coinraters.com',
             sTo, '',
              sMSG);
  splitstring(sMsg, '..', s1,s2);

//  speech.SayNatural(s1);
end;


{ Tcurrencies }

function TPDcurrencies.CCToID(sCurrencyCode: string): int64;
begin
  result := -1;
  rsCurrencies.First;
  while not rsCurrencies.EOF do begin
    if comparetext(rsCurrencies['cc'], sCurrencyCode)=0 then
      exit(rsCurrencies['CurrencyID']);
    rsCurrencies.Next;
  end;
end;

function TPDcurrencies.CCToName(sCurrencyCode: string): string;
begin
  result := '';
  rsCurrencies.First;
  while not rsCurrencies.EOF do begin
    if comparetext(rsCurrencies['cc'], sCurrencyCode)=0 then
      exit(rsCurrencies['Name']);
    rsCurrencies.Next;
  end;
end;

procedure TPDcurrencies.Detach;
begin
  if detached then exit;
  rsCurrencies.free;
  rsCurrencies := nil;
  inherited;

end;

function TPDcurrencies.NameToCC(sName: string): string;
begin
  result := '';
  rsCurrencies.First;
  while not rsCurrencies.EOF do begin
    if comparetext(rsCurrencies['Name'], sName)=0 then
      exit(rsCurrencies['cc']);
    rsCurrencies.Next;
  end;
end;

procedure TPDcurrencies.Refresh(OnlyTradable: boolean; AILive: boolean; AISim: boolean);
begin
  if rsCurrencies <> nil then
    rsCurrencies.free;

  rsCurrencies := ssdb.GetCurrencies(onlytradable, ailive, aisim);

end;

{ TPDQuotes }

function TPDQuotes.AdjustSampleID(sampleid: int64): int64;
begin
  if sampleid < 0 then
    SampleID := highestknownsampleid;

  result := sampleid;
end;

function TPDQuotes.AveragePeriod(samplesize: int64; zerosamplesize:int64; iSampleIDMax: int64 = -1): double;
var
  x: ni;
  idx: ni;
  bIsCrossing: boolean;
  avg, this, last: double;
  crossings: ni;
begin
  iSampleIDMax := AdjustSampleID(iSampleIDMax);

  idx := iSampleIDMax;
  if (idx-samplesize) <= 0 then
      samplesize := idx-1;

  crossings := 0;
  for x := idx downto greaterof((idx-samplesize),1) do begin
    avg := GetAverage(x, zerosamplesize,true);
    this := UnifiedQuotes[x].rate;
    last := UnifiedQuotes[x-1].rate;
    bIsCrossing := ((this>avg) xor (last>avg));
    if bISCrossing then begin
      inc(crossings);
    end;
  end;
  result := crossings / samplesize;


end;

function TPDQuotes.CacheFile: string;
begin
  result := DLLPath+'Quotes\'+ccFrom+'_'+ccTo+'_'+inttostr(DataStart)+'_'+inttostr(FogLimit)+'.quotes';


end;

procedure TPDTrades.CleanStats(upto: int64);
var
  db: TRDTPDB;
  t: ni;
begin
  exit;
  db := dbprov.need;
  try
    t := db.FunctionQuery('select min(statid) from coinstats where messageclass="manage"', 0);
    while t < upto do begin
      db.Writebehind('delete from coinstats where statid < '+inttostr(t));
      inc(t,10);
    end;
  finally
    dbprov.noneed(db);
  end;

end;

function TPDQuotes.realcount: ni;
begin
  result := Length(real_qs);
end;

procedure TPDQuotes.Detach;
begin
  IF DETACHED THEN EXIT;

  rs.free;
  rs := nil;
  rsq.free;
  rsq := nil;

  INHERITED;
end;

procedure TPDQuotes.DownloadToCache(cTo: string; upToSampleID: int64);
var
  rs: TSERowSet;//ok
  mx,mxx: int64;
  thisone: int64;
  remotemax: int64;
  db: TRDTPDB;
begin
  db := dbprov.need;
  try
    if cTo = '' then
      exit;
    cachelocks.GetLock(cTo, true);
     try
      remotemax := db.FunctionQuery('select max(sampleid) from quote',-1);

      if upToSampleID < 0 then
        upToSampleID := remoteMax;

      mx := GetMaxSampleIDInCache+1;
      mxx := lesserof(((uptoSampleid div 500)+1)*500, remotemax);
      if mxx <= mx then
        exit;


      Debug.Log('Downloading '+cTo+' up to '+mxx.tostring);



  //    while mxx <= upToSampleID do begin
        db.ReadQuery_Begin('select * from quote where (sampleid >= '+inttostr(mx)+') and (sampleid <= '+inttostr(mxx)+')and (tocoin="'+cTo+'")');
  //      inc(mxx);
  //    end;

  //    while mx <= upToSampleID do begin
        rs := nil;
        try
          rs := db.ReadQuery_End();
  {$IFDEF INDEX}
          rs.Maintain('sampleid');
  {$ENDIF}
          rs.SavetoFile(quotecachefile(ccTo), true);
          if fileexists( quotecachefile(ccTo)+'.max') then
            deletefile(quotecachefile(ccTo)+'.max');
  //        debug.log(rs.ToString);
        finally
          rs.Free;
          rs := nil;
        end;
        inc(mx);
  //    end;
    finally
      cachelocks.ReleaseLock(cTo, true);
    end;
  finally
    dbprov.NoNeed(db);
  end;

end;

function TPDQuotes.ExtrapolatedCount: ni;
begin
  result := length(fake_qs);
end;

procedure TPDQuotes.FabricateMissingPieces;
var
  rsOut: TSERowSet;//ok
  expected: int64;
begin
  rsOut := nil;
  if rs.rowcount = 0 then
    exit;
  if rs.fieldcount = 0 then
    exit;

  try
    rs.First;
    expected := datastart;

    rsOut := TSERowSet.Create;
    rs.CopyFieldDefsTo(rsOut);
    rsq.CopyFieldDefsTo(rsOut);


    //fake the first record in case DataStart is on a gap
    while rs.CurRecordFields['sampleid'] > expected do begin
      rsOut.AddRow;
      rs.CopyCurrentRecordTo(rsOut);
      rsOut.CurRecordFields['sampleid'] := expected;
      inc(expected);
    end;

    while expected <= fogLimit do begin
      rsOut.AddRow;
      rs.CopyCurrentRecordTo(rsOut);
      rsOut.CurRecordFields['sampleid'] := expected;
      if rs.CurRecordFields['sampleid'] = expected then
        rs.Next;
      inc(expected);
      if rs.eof then begin
        foglimit := expected -1;
        break;
      end;

    end;
    rsOut.first;
    rsq.first;
    while (not rsq.eof) and (not rsOut.eof) do begin
      if rsq['sampleid'] < rsOut['sampleid'] then
        rsq.next
      else
      if rsq['sampleid'] > rsOut['sampleid'] then
        rsOut.Next
      else begin
        rsOut.CopyRecordFromByName(rsq);
        rsOut.next;
        rsq.next;
      end;
    end;

  finally
    rs.free;
    rs := rsOut;
    rsq.free;
    rsq := nil;
  end;


end;

function TPDQuotes.GEtAmplitude(samplesize, zerocrossSampleSize: int64; iSampleIDMax: int64 = -1): double;
var
  t: ni;
begin
  iSampleIDMax := AdjustSampleID(iSampleIDMax);
  Result := 0;
end;

function TPDQuotes.GetAverage(endidx: int64; samplesize: int64; bLatent: boolean): double;
var
  x: ni;
  idx: ni;
begin
  idx := endidx;
  if (idx-samplesize) < 0 then
      samplesize := idx;

  result := 0;

  for x := idx downto greaterof((idx-samplesize),0) do begin
    result := result + UnifiedQuotes[x].rate;
  end;
  result := result / samplesize;
end;

function TPDQuotes.GetExtrapolatedQuote(idx: ni): TQuoteItem;
begin
  result := fake_qs[idx];
end;

function TPDQuotes.GetFrequency(samplesize, zerocrossSampleSize: int64; iSampleIDMax: int64 = -1): double;
begin
  raise ECritical.Create('not implemented');
end;

function TPDQuotes.GetFutureHigh(samplesize, iSampleIDMax: int64): double;
var
  x: ni;
  idx: ni;
begin
  iSampleIDMax := AdjustSampleID(iSampleIDMax);
  idx := IndexOfSampleid(iSampleIDMax);
  if (idx+(samplesize-1)) > unifiedcount then
      samplesize := unifiedcount-idx;

  result := UnifiedQuotes[idx].rate;

  for x := idx to lesserof((idx+(samplesize-1)),unifiedcount-1) do begin
    if UnifiedQuotes[x].rate > result then
      result := UnifiedQuotes[x].rate;
  end;
end;

function TPDQuotes.GetFutureLow(samplesize, iSampleIDMax: int64): double;
var
  x: ni;
  idx: ni;
begin
  iSampleIDMax := AdjustSampleID(iSampleIDMax);
  idx := IndexOfSampleid(iSampleIDMax);
  if (idx+(samplesize-1)) > unifiedcount then
      samplesize := unifiedcount-idx;

  result := UnifiedQuotes[idx].rate;

  for x := idx to lesserof((idx+(samplesize-1)),unifiedcount-1) do begin
    if UnifiedQuotes[x].rate < result then
      result := UnifiedQuotes[x].rate;
  end;
end;

function TPDQuotes.GetHigh(samplesize: int64; iSampleIDMax: int64 = -1): double;
var
  x: ni;
  idx: ni;
begin
  iSampleIDMax := AdjustSampleID(iSampleIDMax);
  idx := IndexOfSampleid(iSampleIDMax);
  if (idx-(samplesize-1)) < 0 then
      samplesize := idx;

  result := UnifiedQuotes[idx].rate;

  for x := idx downto greaterof((idx-(samplesize-1)),0) do begin
    if UnifiedQuotes[x].rate > result then
      result := UnifiedQuotes[x].rate;
  end;
end;

function TPDQuotes.GetItem(idx: ni): TQuoteItem;
begin
  result := real_qs[idx];
end;

function TPDQuotes.GetLow(samplesize: int64; iSampleIDMax: int64 = -1): double;
var
  x: ni;
  idx: ni;
begin
  iSampleIDMax := AdjustSampleID(iSampleIDMax);
  idx := IndexOfSampleid(iSampleIDMax);
  if (idx-(samplesize-1)) < 0 then
      samplesize := idx;

  result := UnifiedQuotes[idx].rate;

  for x := idx downto greaterof((idx-(samplesize-1)),0) do begin
    if UnifiedQuotes[x].rate < result then
      result := UnifiedQuotes[x].rate;
  end;
end;

function TPDQuotes.GetMaxSampleIDInCache: int64;
var
  rs: TSERowSet;
  mx: int64;
begin
  rs := nil;
  cachelocks.GetLock(ccTo, false);
  try
    if not fileexists(quotecachefile(ccTo)) then
      exit(-1);

    if fileexists(quotecachefile(ccTo)+'.max') then
      exit(strtoint(trim(loadfileasstring(quotecachefile(ccTo)+'.max'))));

//    if assigned(rs) then begin
//      rs.free;
//      rs := nil;
//    end;

    mx := -1;
    rs := TSERowSet.create;
    rs.LoadFromfile(QuoteCacheFile(ccTo),
      procedure(rs: TSeRowSet; out accept: boolean; var bBreak: boolean)
      begin
        accept := false;//never accept
        mx := greaterof(mx, rs.CurRecordFields['sampleid']);
      end
    );
    result := mx;

    lockconsole;
    try
      SaveStringAsFile(quotecachefile(ccTo)+'.max',inttostr(result));
    finally
      unlockconsole;
    end;
  finally
    rs.free;
    rs := nil;
    cachelocks.ReleaseLock(ccTo, false);
  end;

end;

function TPDQuotes.GetUnifiedArray(idx: ni): TQuoteItem;
var
  ix: ni;
begin
  if idx < 0 then
    idx := 0;

  if idx > FogLimit then begin
    if idx >= Unifiedcount then
      idx := unifiedcount-1;

    //determine index we want from imaginary quotes
    ix := idx-FogLimit;

    if ix < 0 then
      ix := 0;

    if length(fake_qs) = 0 then
      exit(real_qs[0]);

    result := fake_qs[ix]

  end else
    result := real_qs[idx];

end;

function TPDQuotes.GetUnifiedCount: ni;
begin
  result := realcount + ExtrapolatedCount;
end;

function TPDQuotes.GetValueInUSD(ccIn: string;
  inValue: double; sampleid: int64 = -1 ): double;
begin
  result := ssdb.GetValueInUSD(ccIn, inValue, sampleid);
end;

function TPDQuotes.GetVolatility(samplesize: int64; iSampleIDMax: int64 = -1): double;
begin
  result := GetHigh(samplesize, iSampleIDMax) - GetLow(samplesize, iSampleIDMax);

end;

function TPDQuotes.IndexOfSampleid(sampleid: int64): ni;
var
  t: ni;
begin
  for t:= 0 to UnifiedCount-1 do begin
    if UnifiedQuotes[t].sampleid = sampleid then
      exit(t);
  end;

  exit(-1);

end;

procedure TPDQuotes.LoadFromCache;
var
  fs: TMultiBufferMemoryFileStream;
  i: int64;
begin
  if not fileexists(cachefile) then
    raise ECritical.create('cache file not found '+cachefile);

  fs := TMultiBufferMemoryFileStream.create(cachefile, fmOpenRead);
  try
    stream_GuaranteeRead(fs, pbyte(@i), sizeof(i));
    setlength(real_qs, i);
    stream_GuaranteeRead(fs, pbyte(@i), sizeof(i));
    setlength(fake_qs, i);
    stream_GuaranteeRead(fs, @real_qs[0], length(real_qs)*sizeof(TQuoteItem));
    stream_GuaranteeRead(fs, @fake_qs[0], length(fake_qs)*sizeof(TQuoteItem));
  finally
    fs.free;
  end;
end;

procedure TPDQuotes.LoadQuotesFromCache(cFrom, cTo: string; iSampleIDLimit: int64 = -1;iSampleIDStart: int64 = 0);
var
  rsLocal: TSERowSet;
begin
  cachelocks.GetLock(cTo, false);
  try
    if assigned(rs) then begin
      rs.free;
      rs := nil;
    end;

    rsLocal := TSERowSet.create;
    rsLocal.LoadFromfile(quotecachefile(cTo),
      procedure(rsParam: TSeRowSet; out accept: boolean; var bBreak: boolean)
      begin
        accept := (comparetext(rsParam.CurRecordFields['fromcoin'],cFrom) = 0)
            and   (comparetext(rsParam.CurRecordFields['tocoin'],cTo) = 0)
            and   ((iSAmpleIDLimit < 0) or (rsParam.CurRecordFields['sampleid'] <= iSAmpleIDLimit))
            and   ((iSAmpleIDStart < 0) or (rsParam.CurRecordFields['sampleid'] >= iSampleIDSTart));
        bBreak := rsParam.CurRecordFields['sampleid'] > iSAmpleIDLimit;
        //Debug.Log(booltostr(accept));
      end
{$IFDEF INDEX}
    , 'sampleid', iSampleIDStart
{$ENDIF}
    );
//    Debug.log(rsLocal.ToString);
  finally
    cachelocks.ReleaseLock(cTo, false);
  end;


  self.rs := rsLocal;

  Rollup;



end;

function TPDQuotes.QuoteCacheFile(cc: string): string;
begin
  result := dllpath+'\quotes\'+cc+'.rs';
end;

procedure TPDQuotes.Refresh(cFrom, cTo: string; iSampleIDLimit: int64 = -1;iSampleIDStart: int64 = 0);

{$IFDEF LOCAL_CACHE}
begin
  if cFrom = '' then exit;
  if cTo = '' then
    exit;
  ccFrom := cFrom;
  ccTo := cTo;
  DownloadToCache(cTo, iSampleIDLimit);
  LoadQuotesFromCache(cFrom, cTo, iSampleIDLimit, iSampleIDStart);

end;
{$ELSE}
var
  Pre, Post: TQuotesAndVolume;
  iFirst: int64;
  iLast: int64;
  xxx: int64;
  qav: TQuotesAndVolume;
  db: TRDTPDB;
//  ssdb: TShapeShiftDB;
begin
  db := nil;
//  ssdb := nil;
  try
    db := dbprov.Need;
//    ssdb := prov.need;

    ccFrom := cFrom;
    ccTo := cTo;
    FogLimit := iSampleIDLimit;
    DataStart := iSampleIDStart;

    if  fileExists(cachefile) then begin
      LoadFromCache;
      exit;
    end;

    highestKnownSampleID := db.FunctionQuery('select max(sampleid) from quote', 0);

    if assigned(rs) then begin
      iFirst := 0;
      iLast := 0;
      if rs.RowCount > 0 then begin
        iFirst := rs.Values[0,0];
        iLast := rs.Values[0,rs.rowcount-1];
      end;
      if (rs.rowcount = 0) or
      (iFirst > iSampleIDStart)
      or (iLast < iSampleIDLimit)
      or (cFrom <> ccFrom)
      or (cTo <> ccTO) then begin
        rs.free;
        rs := nil;
      end;
    end;



    xxx := iSampleIDStart;
    if iSampleIDLimit > 0 then begin
      if (iSampleIDLimit -2048) < iSampleIDStart then begin
        iSampleIDStart := greaterof(iSampleIDLimit-2048, 0);
        datastart := iSampleIDStart;
      end;
    end;



    //if we don't already have a rowset, then get a new one with one query
    if rs = nil then begin

      qav := ssdb.GetQuotes(cFrom, cTo, iSampleIDLimit, isampleIDStart);
      rs := qav.quotes.o;
      rsq := qav.volume.o;
    end else begin
      //determine if we are to prepend and append
      iFirst := rs.Values[0,0];
      iLast := rs.Values[0,rs.rowcount-1];
      if iFirst > iSampleIDStart then begin
        pre := ssdb.GetQuotes(cFrom, cTo, iSampleIDLimit, iFirst-1);
        rs.Prepend(pre.quotes.o);
        rsq.Prepend(pre.volume.o);
      end;
      if (iLast < iSampleIDLimit) or (iSampleIDLImit < 0) then begin
        Post := ssdb.GetQuotes(cFrom, cTo, iLast+1, iSampleIDLimit);
        rs.Append(Post.quotes.o);
        rsq.Append(post.volume.o);
      end;
    end;
  finally
    dbprov.noneed(db);
//    prov.noneed(ssdb);
  end;

  FabricateMissingPieces;
  Rollup;

  SavetoCache;

end;
{$ENDIF}

procedure TPDQuotes.RollUp;
var
  t: ni;
  q: TquoteItem;
  q_ex: array of double;
  q_ex2: array of double;
  EX1,EX2: int64;
  function Rollback(idx: ni; distance: ni; bLatent: boolean): double;
  var
    avg: double;
    x: ni;
    xx: ni;
    cnt: ni;
  begin
    avg := 0;
    cnt := 0;
    if (idx-distance) < 0 then
      distance := idx;
    for x := idx downto greaterof((idx-distance),0) do begin
      if not bLatent then
        xx := x+(distance shr 1)
      else
        xx := x;
      if xx < UnifiedCount then begin
        avg := avg+UnifiedArray[xx].rate;
        inc(cnt);
      end;
    end;
    result := avg / cnt;
  end;

begin
  setlength(real_qs, rs.RowCount);

  //put rates in
  rs.First;
  for t:= 0 to high(real_qs) do begin
    q := real_qs[t];
    if rs['Rate'] = 0 then
      q.rate := 0
    else
      q.rate := 1/rs['Rate'];

    if (t>0) and (q.rate = 0) then
      q.rate := real_qs[t-1].rate;

    q.volumeBuy15 := vartodoublenull(rs['BuyVolume15'],0.0);
    q.volumeBuy30 := vartodoublenull(rs['BuyVolume30'],0.0);
    q.volumeBuy60 := vartodoublenull(rs['BuyVolume60'],0.0);
    q.volumeBuyDay := vartodoublenull(rs['BuyVolumeDay'],0.0);
    q.volumeBuy240 := vartodoublenull(rs['BuyVolume240'],0.0);

    q.volumeSell15 := vartodoublenull(rs['SellVolume15'],0.0);
    q.volumeSell30 := vartodoublenull(rs['SellVolume30'],0.0);
    q.volumeSell60 := vartodoublenull(rs['SellVolume60'],0.0);
    q.volumeSellDay := vartodoublenull(rs['SellVolumeDay'],0.0);
    q.volumeSell240 := vartodoublenull(rs['SellVolume240'],0.0);

    q.volumeNet15 := vartodoublenull(rs['NetVolume15'],0.0);
    q.volumeNet30 := vartodoublenull(rs['NetVolume30'],0.0);
    q.volumeNet60 := vartodoublenull(rs['NetVolume60'],0.0);
    q.volumeNetDay := vartodoublenull(rs['NetVolumeDay'],0.0);
    q.volumeNet240 := vartodoublenull(rs['NetVolume240'],0.0);


    real_qs[t] := q;
    rs.next;
  end;


  //FFT
  setlength(q_ex,0);
  setlength(q_ex2,0);
  setlength(fake_qs,0);
  EX2 := highorderbit(lesserof(1440*7,realcount));
  EX1 := EX2-1;
  EX2 := 1 shl EX2;
  Ex1 := 1 shl EX1;
  Ex1 := greaterof(2048, EX1);
  Ex2 := greaterof(4096, EX2);

{$IFDEF EXTRAPOLATE}
  if length(real_qs) >=EX1 then begin
    //now extrapolate using FFT
    setlength(q_ex, EX2);
    setlength(q_ex2, EX2);
    //put rates into FFT array
    for t:= 0 to EX1-1 do begin
      q_ex[t] := real_qs[(high(real_qs)-(EX1-1))+t].rate;
    end;
//    FFT_RealToComplex_Normalized(2048, @q_ex[0], @q_fft[0]);
//    FFT_ComplexToReal_Normalized_Extrapolate(2048, 4096, @q_fft[0], @q_ex[0]);
    FFT_Extrapolate_Predictive(EX1, EX2, @q_ex[0], @q_ex2[0]);
    //rollup FFT stuff
    setlength(fake_qs, EX1);
    for t:= 0 to EX1-1 do begin
      q.rate := q_ex2[t+EX1];//+real_qs[high(real_qs)].rate;
      unifiedarray[t+length(real_qs)] := q;
    end;


  end;
{$ENDIF}

  //rollup non-FFT stuff
  rs.First;
  for t:= 0 to high(real_qs) do begin
    q := UnifiedArray[t];
    q.avgHour := Rollback(t, 60, false);
    q.avgDay := Rollback(t, 60*24, false);
    q.avgWeek := Rollback(t, 60*24*7, false);
    q.avgHour_Latent := Rollback(t, 60, true);
    q.avgDay_Latent := Rollback(t, 60*24, true);
    q.avgWeek_Latent := Rollback(t, 60*24*7, true);

    q.cid := rs['quoteid'];
    q.sampleid := rs['sampleid'];
    q.minerfee := rs['minerfee'];
    UnifiedArray[t] := q;
    rs.next;
  end;

{$IFDEF EXTRAPOLATE}
  if length(real_qs) >= EX1 then begin
    //rollup FFT stuff
    setlength(fake_qs, EX1);
    for t:= 0 to EX1-1 do begin

      q := Unifiedarray[lesserof(EX1,t)+length(real_qs)];
      q.avgHour := Rollback(t+length(real_qs), 60, false);
      q.avgDay := Rollback(t+length(real_qs), 60*24, false);
      q.avgWeek := Rollback(t+length(real_qs), 60*24*7, false);
      q.avgHour_Latent := Rollback(t+length(real_qs), 60, true);
      q.avgDay_Latent := Rollback(t+length(real_qs), 60*24, true);
      q.avgWeek_Latent := Rollback(t+length(real_qs), 60*24*7, true);

      q.sampleid := FogLimit + t;
      if q.rate = 0 then
        debug.log('trap');
      UnifiedArray[t+length(real_qs)] := q;
    end;

  end;
{$ENDIF}

  Debug.Log(self.DataStart.tostring+' '+self.FogLimit.tostring+' '+self.usablecount.tostring);


end;

procedure TPDQuotes.SavetoCache;
var
  fs: TFileStream;
  i: int64;
begin
  fs := TFileStream.create(cachefile, fmCreate);
  try

    i := length(real_qs);
    stream_GuaranteeWrite(fs, pbyte(@i), sizeof(i));

    i := length(fake_qs);
    stream_GuaranteeWrite(fs, pbyte(@i), sizeof(i));

    stream_GuaranteeWrite(fs, @real_qs[0], length(real_qs)*sizeof(TQuoteItem));
    stream_GuaranteeWrite(fs, @fake_qs[0], length(fake_qs)*sizeof(TQuoteItem));

  finally
    fs.free;
  end;
end;

procedure TPDQuotes.SetUnifiedArray(idx: ni; const Value: TQuoteItem);
begin
  if idx > high(real_qs) then
    fake_qs[idx-length(real_qs)] := value
  else
    real_qs[idx] := value;

end;

procedure TPDQuotes.SetUnifiedCount(const Value: ni);
begin
  FUnifiedCount := Value;
end;

function TPDQuotes.UsableCount: ni;
begin
  result := realcount + ((length(fake_qs) div 1440) * 1440);
//  result := UnifiedCount-15;
end;

{ TPDHoldings }

function TPDHoldings.Count: ni;
begin
  result := rs.RowCount;
end;

procedure TPDHoldings.Detach;
begin
  if detached then exit;
  rs.free;
  rs := nil;
  inherited;

end;

function TPDHoldings.GetCurrencies(idx: ni): string;
begin
  rs.Cursor := idx;
  result := rs['CurrencyCode'];

end;

function TPDHoldings.GEtHoldings(cc: string): double;
begin
  result := 0.0;
  rs.First;
  while not rs.EOF do begin
    if rs['CurrencyCode'] = cc then
      exit(rs['holding']);

    rs.next;
  end;

end;

procedure TPDHoldings.Refresh(maxsampleid: int64);
begin
  if rs <> nil then
    rs.free;

  rs := ssdb.GetHoldings(maxsampleid);

end;

{ TQuoteItem }

procedure TQuoteItem.LoadFromStream(s: TStream);
begin
  stream_GuaranteeRead(s, pbyte(@self), sizeof(self));
end;

procedure TQuoteItem.SavetoStream(s: TStream);
begin
  stream_GuaranteeWrite(s, pbyte(@self), sizeof(self));

end;


{ TShapeShiftDomain }

procedure TShapeShiftDomain.Detach;
begin
  if detached then exit;
  prov.noneed(ssdb);
  btx.free;
  btx := nil;
  bin.free;
  bin := nil;
  inherited;

end;

procedure TShapeShiftDomain.DispatchMessage(m: TDomainMessage);
begin
  //
end;

procedure TShapeShiftDomain.Init;
begin
  inherited;
  ssdb := prov.need(false);
  btx := TBTXClient.create;
  bin := TBinanceClient.create;

end;

procedure TShapeShiftDomain.SetSimulated(const Value: boolean);
begin
  FSimulated := Value;
  ssdb.Simulated := value;
end;

{ TPDTrades }


procedure TPDTrades.AddMarketScore(ms: TMarketScore);
begin
  lock;
  try
    setlength(marketscores, length(marketscores)+1);
    marketScores[high(marketscores)] := ms;
  finally
    unlock;
  end;
end;

function TPDTrades.AllowedToSell(sCoin: string): boolean;
begin
  result := ssdb.allowedToSell(sCoin);

end;


procedure TPDTrades.BeginClosePosition(p: POpenPOsition; tomarket: string = 'BTC');
var
  j,f: IJSONHolder;
var
  oba: TorderBookAnalysis;
begin
  oba := btx.GetOrderBookAnalysis(tomarket, p.coin, btIamSelling, p.buyamount,false);
  p.currentrate := oba.crav.convertedRate;
  if ((p.UnitsToProcess * p.currentRate) < BTX_DUST) and (((p.UnitsToProcess * p.currentRate) > 0.0)) then begin
    ssdb.CoinLog('btc', p.coin, 'dust!');
    p.status := 'DUST! Units:'+sat(p.unitstoprocess)+' value '+sat(p.UnitsToProcess * p.currentRate);
//    p.state := POSITIONSTATE_ABANDONED_DUST;
//    ssdb.ChangePositionState(p.id, p.state);
  end else begin
    ssdb.CoinLog(tomarket, p.coin, 'Sell position of '+sat(p.buyamount)+' at '+SAT(OBA.CRAV.finalrate));
    if true then begin
      ssdb.CoinLog(tomarket, p.coin, 'Selling via classic path.');
      j := btx.SellLimit(tomarket+'-'+p.coin, p.UnitsToProcess, oba.crav.finalRate);
      ssdb.CoinLog(tomarket, p.coin, 'Sell Request Submitted');
      if j.o['success'].value = true then begin
        ssdb.CoinLog(tomarket, p.coin, 'Sell Successful');
        p.state := POSITIONSTATE_SELLING;
        p.SellUUID := j.o['result']['uuid'].AsString;
        ssdb.ChangePositionState(p.id, p.state);
      end else begin
        ssdb.CoinLog(tomarket, p.coin, 'When closing '+p.coin+' '+j.o['message'].AsString);
        if comparetext(j.o['message'].asstring,'insufficient_funds')=0 then begin
          p.state := POSITIONSTATE_CANCEL;
          ssdb.ChangePositionState(p.id, p.state);
        end;
      end;
    end;
  end;
end;

procedure TPDTrades.BeginOpenPosition(p: POpenPosition; frommarket: string = 'USDT'; forceRate: double = 0.0);
var
  j: IJSONHolder;
  oba: TOrderBookAnalysis;
  useRate: double;
begin
  if not Gallownewpositions then
    exit;

  oba := btx.GetOrderBookAnalysis('BTC', p.coin, btIamBuying, p.buyCost,false);

  p.currentrate := oba.crav.finalRate;
  p.buyrate := oba.crav.finalRate;
  p.peakrate := p.buyrate;
  p.lowestRate := p.buyrate;
  if forcerate > 0.0 then begin
    useRate := forceRate;
  end else begin
    useRate := oba.crav.finalRate*1.05;
  end;

  var sellValueForDustCheck := BTX.GetOrderBookAnalysis('btc', p.coin, btIamSelling, p.buyamount, false);
  if sellValueForDustCheck.crav.BaseAmount < (BTX_DUST*2) then begin
    ssdb.CoinLog(p.base, p.coin, 'cannot buy dust! '+sat(sellValueForDustCheck.crav.BaseAmount));
  end;


  ssdb.CoinLog(p.base, p.coin, 'buy '+sat(p.buyamount)+' '+p.coin+' at '+sat(useRate)+' for '+sat(p.buycost));
  ssdb.BeginOpenPosition(p.id, p.id);
  j := btx.BuyLimit('BTC-'+p.coin, p.buycost / useRate, useRate);
  if not j.o['success'].value then begin
      ssdb.CoinLog('btc', p.coin, 'buy failed '+j.o['message'].value);
      p.state := POSITIONSTATE_CANCEL;
      if lowercase(j.o['message'].value) = 'insufficient_funds' then begin
        p.state := POSITIONSTATE_WATCHING;
        p.refreshrate := 300000;
      end else begin
        ssdb.CoinLog('btc', p.coin, 'FAILED buy '+j.o['message'].value);
        try
          CoinMail('failed '+sat(p.buyamount)+' '+p.coin+' at '+sat(userate)+' for '+sat(p.buycost)+' '+j.o['message'].value);
        except
        end;
      end;
  end
  else begin
    p.state := POSITIONSTATE_BUYING;
    p.BuyUUID := j.o['result']['uuid'].AsString;
    SavePosition(p^);
    ssdb.CoinLog('btc', p.coin, 'change trans hash to '+p.Buyuuid);
    ssdb.ChangePositionState(p.id, p.state);
    ssdb.CoinLog('btc', p.coin, 'quick change position state '+p.state.tostring);
    ssdb.GetOpenPositions(-1).free;

    try
      //CoinMail('buy '+sat(p.buyamount)+' '+p.coin+' at '+sat(oba.crav.finalRate)+' for '+sat(p.buycost));
    except
    end;
  end;
  SavePosition(p^);
  ssdb.CoinLog('btc', p.coin, 'buy position saved');

end;

procedure TPDTrades.ChartToStats(ex: string; c: TChartAnalysis;
  behind: boolean);
begin
  raise Ecritical.create('deprecated');
end;

function TPDTrades.CheckPositions(Liquidate: boolean; thr: TManagedThread): boolean;
begin
  result := strat.ManageTrades(Liquidate, thr);
  result := true;
end;

procedure TPDTrades.ClearWatching;
begin
  lock;
  try
    setlength(watching,0);
  finally
    unlock;
  end;
end;

constructor TPDTrades.Create;
begin
  inherited;
  strat := TTUSD_USDTStrategy.create;
  strat.pdTrades := self;
end;

function TPDTrades.CreatePosition(ex, sBase, sCoin: string; amountToSpend,
  maxrate: double; strategy: double; jsCreate: string): string;
var
//  j: IHolder<TJSON>;
  id: int64;
  p: TOpenPosition;
begin
  if lowercase(sCoin) = 'btc' then begin
    exit;
  end;

  p.init;
  //submit request to bittrex
  //j := btx.BuyLimit('BTC-'+sCoin, amountToSpend/maxrate, maxrate);

  //record uuid in positions table
  id := round(now*60*60*24);

  p.base := sBase;
  p.coin := sCoin;
  p.id := id;
  p.buyCost := amountToSpend;
  p.buyrate := maxrate;
  p.buyamount := amountToSpend/maxrate;
  p.peakRate := maxrate;
  p.lowestRate := maxrate;
  p.CurrentRate := maxrate;
  p.CurrentValue := p.currentrate * p.buyAmount;
  p.peakValue := p.peakRate * p.buyamount;
  p.lowestValue := p.lowestRate * p.buyamount;
  p.strategy := round(strategy);
  p.TypicalSwing := 0.0;
  p.HistoricalBottom := 0.0;
  p.jscreate := jscreate;
  p.statex := '';

  ssdb.CreatePosition(@p);
  ssdb.CoinLog('btc', p.coin, 'Create position.');

  //watch trade

end;

destructor TPDTrades.Destroy;
begin
  cryptCompare.free;
  cryptCompare := nil;
  rsOpenTrades.free;
  rsopentrades := nil;
  strat.Free;
  strat := nil;
  inherited;
end;

procedure TPDTrades.DispatchMessage(m: TDomainMessage);
begin
  inherited;
  if m.typ = 'ordercompleted' then begin
    //do something when order completes
  end;
end;

procedure TPDTrades.Fetch;
var
  rs: TSErowSet;//ok
  t: ni;
begin
  rs := ssdb.GetOpenPositions(-1);
  try
    Lock;
    try
      setlength(trades,rs.RowCount);
    finally
      Unlock;
    end;
    rs.First;
    for t:= 0 to high(trades) do begin
      trades[t].id := rs['transactionid'];
      TRADES[T].Fstate := rs['state'];
      trades[t].base := rs['basecoin'];
      trades[t].coin := rs['marketcoin'];
      trades[t].buycost := rs['buycost'];
      trades[t].buyamount := rs['buyamount'];
      trades[t].buyrate := rs['buyRate'];
      trades[t].sellrate := rs['sellRate'];
      trades[t].buytime := rs['buyTime'];
      trades[t].selltime := rs['SellTime'];
      trades[t].created := rs['created'];
      trades[t].BuyUUID := rs['buyuuid'];
      trades[t].SellUUID := rs['selluuid'];
      trades[t].peakValue := rs['PeakValue'];
      trades[t].lowestValue := rs['LowestValue'];
      trades[t].currentValue := rs['CurrentValue'];
      trades[t].peakRate := rs['PeakRate'];
      trades[t].lowestRate := rs['LowestRate'];
      trades[t].currentRate := rs['CurrentRate'];
      trades[t].strategy := rs['strategy'];
      trades[t].HistoricalBottom := rs['HistoricalBottom'];
      trades[t].UnitsToProcess := rs['UnitsToProcess'];
      trades[t].RefreshRate := rs['refreshrate'];
      trades[t].lastStateChange := rs['stateChangeTime'];
      trades[t].because:= rs['because'];





  //    trades[t].expires := rs['Expires'];

      rs.Next;
    end;
  finally
    rs.free;
  end;

end;

procedure TPDTrades.FindAndPushTweets(sCoin: string);
var
  tw: TTwitterClient;
  h: IHolder<TJSON>;
  t: ni;
begin
  exit;
  tw := TTwitterEvilRobot.create;
  try
    try
      h := tw.SearchTweets('$'+sCOIN);
      ssdb.SaveTweets(sCoin, h);
    except
    end;
  finally
    tw.free;
  end;

end;

function TPDTrades.FindMarketScore(coin: string): PMarketScore;
var
  t: ni;
begin
  lock;
  try
  result := nil;
  for t := 0 to high(marketScores) do
    if CompareText(marketScores[t].coin, coin)=0 then
      exit(@marketScores[t]);
  finally
    unlock;
  end;

end;

function TPDTrades.FindOpenPosition(id: int64): PopenPosition;
var
  t: ni;
begin
  result := nil;
  for t:= 0 to high(trades) do
    if trades[t].id = id then
      exit(@trades[t]);

end;

function TPDTrades.FindOpenPosition(sCoin: string; iWindowSize: ni): POpenPosition;
var
  t: ni;
begin
//  if length(trades) = 0 then
  Fetch;
  result := nil;
  for t:= 0 to high(trades) do
    if (trades[t].strategy = iWindowSize) and (CompareText(trades[t].coin, sCoin)=0) then
      exit(@trades[t]);
end;

function TPDTrades.FindPrevMarketScore(coin: string): PMarketScore;
var
  t: ni;
begin
  lock;
  try
    result := nil;
    for t := 0 to high(PreviousmarketScores) do
      if CompareText(PreviousmarketScores[t].coin, coin)=0 then
        exit(@PreviousmarketScores[t]);
  finally
    unlock;
  end;

end;

function TPDTrades.FindRecentPositionTime(sBase, sMarket: string; istrategy: ni): TDateTime;
begin
  result := ssdb.FindRecentPositionTime(sBase, sMarket, istrategy);
end;

procedure TPDTrades.FixSocialVelocity(coin: string);
var
  db: TRDTPDB;
  h: IHolder<TSERowset>;
  tsStart: string;
  t: ni;
  slValues: TStringlist;
  s: string;
  sv: double;
  lt: TDateTime;
begin
  lt := 0.0;
  slValues := TStringlist.create;
  try
    db := dbprov.Need;
    try
      tsStart := DatetoMYSQLDate(now-7);
      db.WriteQuery('delete from coinstats_social_velocity where marketcoin='+quote(coin)+' and messageclass="social_velocity" and ts>'+quote(tsStart));
      h := db.ReadQueryH('select * from coinstats_social_points where marketcoin='+quote(coin)+' and messageclass="social_points" and ts>'+quote(tsStart));
      h.o.First;
      while not h.o.EOF do begin
        Debug.Log('FIX '+coin+' row '+h.o.Cursor.tostring+' of '+h.o.RowCount.tostring);
        if h.o['ts'] < lt+0.05 then begin
          h.o.next;
          continue;
        end;
        lt := h.o['ts'];
        sv := ssdb.GetSocialVelocity(coin, 1, h.o['ts']);
        slValues.add(self.ssdb.GetCoinStatValueInsert('BTC', coin, 'social_velocity', sv.tostring, h.o['ts'], h.o['statid'], h.o['openid']));
        h.o.next;
      end;

      s := UnParseString(',', slValues);
      db.Writebehind('insert ignore into coinstats_social_velocity values '+s);


    finally
      dbprov.NoNeed(db);
    end;
  finally
    slValues.Free;
  end;
end;

procedure TPDTrades.FollowCoin(coin, twitterhandle: string);
var
  tw: TTwitterEvilRobot;
  j: IJSONHolder;
begin
  tw := TTwitterEvilRobot.create;
  try
//    j := tw.Follow(twitterhandle);
//    if j.o.HasNode('name') then begin
      ssdb.LinkTwitter(coin, twitterhandle);
//    end;


  finally
    tw.free;
  end;

end;

procedure TPDTrades.ForceClose(id: int64);
begin
  ssdb.ForceClose(id);

end;

function TPDTrades.GetAndPushChartData(ex, cBase, cMarket: string;
  period: TChartPeriod): TArray<TChartRec>;
begin
  if ex = 'btx' then
    result := btx.GetChartData(cBase, cMarket, period)
  else
    result := bin.GetChartData(cBase, cMarket, period);

  var c :TCmd_ChartToStats :=  Tcmd_ChartToStats.Create;
  c.cd := result;
  c.fireforget := true;
  c.start;



end;

function TPDTrades.GetAverageMarketHighsFreq: TMarketFrequency;
var
  ms: TMarketScore;
begin
  lock;
  try
    result.Amp := 0;
    result.Freq := 0;
    for ms in marketScores do begin
      result.Amp := result.Amp + ms.anal.FreqHighs.Amp;
      result.Freq := result.Freq + ms.anal.FreqHighs.Freq;
    end;
    result.Amp := result.amp / length(marketscores);
    result.Freq := result.Freq / length(marketscores);
  finally
    unlock;
  end;
end;

function TPDTrades.GetAverageMarketLowsFreq: TMarketFrequency;
var
  ms: TMarketScore;
begin
  lock;
  try
  result.Amp := 0;
  result.Freq := 0;
  for ms in marketScores do begin
    result.Amp := result.Amp + ms.anal.FreqLows.Amp;
    result.Freq := result.Freq + ms.anal.FreqLows.Freq;
  end;
  result.Amp := result.amp / length(marketscores);
  result.Freq := result.Freq / length(marketscores);

  finally
  unlock;
  end;
end;

function TPDTrades.GetChartRange(ex, cbase, cmarket: string; period: TChartPeriod;
  dtstart, dtend: TDateTime): TArray<TchartRec>;
begin
  result := ssdb.GetChartRange(ex, cbase, cmarket, ord(period), dtStart, dtEnd);


end;

function TPDTrades.GetCMCCoin(sCoin: string): TCMCRecord;
var
  t: ni;
begin
  if CompareText(sCoin, 'bcc')=0 then begin
    sCoin := 'BCH';
  end;
  result.init;
  for t:= 0 to high(cmc) do begin
    result := cmc[t];
    if comparetext(result.symbol,lowercase(sCoin))=0 then begin
      exit;
    end;
  end;

end;

function TPDTrades.UpdateClimateAssessment: double;
var
  t: ni;
  h: IJSONHolder;
  h2: IJSONHolder;
  anal: TChartAnalysis;
  res: TJSON;
  gainers, losers: ni;
  rep: TClimateReport;
begin
  rep := ssdb.GetClimateReport('MarketClimate');
  if rep.age < 0.1 then begin
    climateAssessment := rep.value;
    lastClimateAssessment := getTicker;
    result := rep.value;
    exit;
  end;

  if (lastClimateAssessment = 0) or
  (gettimesince(lastClimateAssessment) > 1000*60*60) then begin

    h := btx.GetMarketSummaries('BTC');
    h.o['result'].Sorti('BaseVolume');
    gainers := 0;
    losers := 0;
    for t := 0 to h.o['result'].iCount-1 do begin
      anal := btx.GetChartAnalysis('BTC', h.o['result'][t]['MarketCurrency'].AsString, cp1);


      if anal.Slope > 0.0 then
        inc(gainers)
      else
        inc(losers);

    end;

    climateAssessment := gainers/(gainers+losers);
    result := climateAssessment;
    lastClimateAssessment := getticker;

    rep.Init;
    rep.timestamp := now;
    rep.reportName := 'MarketClimate';
    rep.value := climateAssessment;
    ssdb.SaveClimateReport(rep);



  end else begin
    result := climateAssessment;
  end;
end;

function TPDTrades.GetMarketComparison(sCoin: string): PMarketComparison;
var
  t: ni;
begin
  for t := 0 to high(crypt) do begin
    if comparetext(crypt[t].cryptopia.marketCurrency, sCoin) = 0 then
      exit(@crypt[t]);
  end;

  exit(nil);

end;

function TPDTrades.GetOrderBookAction(sBase, sAlt: string): double;
begin
  result := GetOrderBookAction(sBase, sAlt, btIAmBuying);
  result := result + GetOrderBookAction(sBase, sAlt, btIAmSelling);

end;

function TPDTrades.GetOrderBookActionBalance(sBase, sAlt: string): double;
begin
  result := 0-GetOrderBookAction(sBase, sAlt, btIAmBuying);//<<SELLERS are NEGATIVE
  result := result + GetOrderBookAction(sBase, sAlt, btIAmSelling);//<BUYERS ARE POSITIVE
end;

function TPDTrades.GetOrderBookAction(sBase, sAlt: string; bt: TBookType): double;
var
  sCachevar: string;
  rec: TJSONcacheRec;
  old, nu: IJSONHolder;
  pqOld: array of TPriceAndQuantity;
  pqNu: TPriceAndQuantity;
  t: ni;
  tmdif: ticker;
  scale: double;
  function HasPriceAtQuantity(p,q: double): boolean;
  var
    x: ni;
  begin
    for x := 0 to high(pqOld) do begin
      if pqOld[x].price = p then begin
        exit(pqOld[x].qty = q);
      end;
    end;
    exit(false);
  end;
begin
  if bt = btIamSelling then begin
    sCacheVar := 'Book_IamSelling_'+sBase+'-'+sAlt;
  end else begin
    sCacheVar := 'Book_IamBuying'+sBase+'-'+sAlt;
  end;


  nu := btx.GetOrderBook(sBase, sAlt, bt);
  rec := GJSONCache.Find(sCacheVar);
  old := rec.j;
  try
    if rec.j = nil then
      exit(0.0);
  finally
    GJSONCache.Add(sCacheVar, nu);
  end;

  setlength(pqOld, old.o['result'].iCount);
  for t := 0 to high(pqOld) do begin
    pqOld[t].price := old.o['result'][t]['Rate'].value;
    pqOld[t].qty := old.o['result'][t]['Quantity'].value;
  end;

  result := 0;
  for t := 0 to nu.o['result'].iCount-1 do begin
    pqNu.price := nu.o['result'][t]['Rate'].value;
    pqNu.qty := nu.o['result'][t]['Quantity'].value;

    if not HasPriceAtQuantity(pqNu.price, pqNu.qty) then begin
      result := result + 1.0;
    end;
  end;


  //normalize to 50 actions in 2.5 minutes
  tmDif := GetTimeSince(getticker, rec.created);

  scale := ((60*2.5)*1000)/tmDif;
  result := result * scale;
  result := result / 250;


end;

function TPDTrades.GetTradeByUUID(sUUID: string): TOpenPosition;
begin
  raise ECritical.create('unimplemented');
end;

function TPDTrades.GetTradecount: ni;
begin
  Lock;
  try
    RESULT := LENGTH(TRADES);
  finally
    Unlock;
  end;

end;



procedure TPDTrades.Init;
begin
  inherited;
  climateAssessment := 1.0;
  bitcoinClimate := 0.0;
  cryptCompare := TCryptCompare.create;

end;

function TPDTrades.IsAlreadyWatching(sBase, sCoin: string): boolean;
begin
  Fetch;
  for var t := 0 to high(trades) do begin
    if (trades[t].state = 0)
    and (comparetext(trades[t].base, sBase)=0)
    and (comparetext(trades[t].coin, sCoin)=0) then begin
      exit(true);
    end;
  end;

  exit(false);
end;

function TPDTrades.IsCryptopiaMarket(sCoin: string): boolean;
var
  mc: TMarketComparison;
begin
  for mc in crypt do
    if comparetext(mc.cryptopia.marketCurrency, sCoin) = 0 then
      exit(true);

  exit(false);

end;

function TPDTrades.IsDuplicatePosition(p: TOpenPosition; stateLow, stateHigh: ni): boolean;
var
  t: ni;
begin
  for t:= 0 to high(trades) do begin
    var matchesState := true;
    if stateHigh > 0 then begin
      matchesState := (p.state >=stateLow) and (p.state <= stateHigh);
    end;

    if matchesState
    and (compareText(trades[t].coin,p.coin)=0)
    and (p.strategy = trades[t].strategy)
    and (p.id <> trades[t].id) then begin
      exit(true);
    end;
  end;
  exit(false);

end;

procedure TPDTrades.LiquidateDust;
var
  h: IHOLDER<TJSON>;
  t: ni;
  jv: TJSON;
  cur: string;
  amt: double;
  oba: TorderBookAnalysis;
begin
  h := btx.GetBalances;
  for t:= 0 to h.o['result'].iCount-1 do begin
    //get the node
    jv := h.o['result'][t];
    cur := jv['Currency'].value;
    if lowercase(cur)='btc' then
      continue;
    amt := jv['Balance'].Value;
    oba := btx.GetOrderBookAnalysis('btc', cur, btIAmSelling, amt, false);
    if (amt*oba.crav.finalRate) > BTX_DUST then begin
       btx.SellLimit('BTC-'+cur, amt, oba.crav.finalRate);
    end;

  end;


end;

function TPDTrades.LoadSignalBuckets(sBase,
  sMarket: string): TBuckets;
begin
    result := ssdb.LoadSignalBuckets(sBase, sMarket);



end;

procedure TPDTrades.MarketUpdated(ms: TMarketScore);
var
  pms: PMarketScore;
begin
  lock;
  try
  pms := FindMarketScore(ms.coin);
  if pms = nil then
    AddmarketScore(ms)
  else
    pms^ := ms;


  SortMarketScores;
  finally
  unlock;
  end;

end;

procedure TPDTrades.PickToScan_Enroyd;
var
  hBTXMarkets: IHolder<TJSON>;
  hEnroydMarkets: IHolder<TJSON>;
  hMerged: Iholder<TJSON>;
  s: string;
  t: ni;
  csBTC: TCoinSlope;
  csCOIN: TCoinSlope;

  function ScoreCoin(coin: string): double;
  begin
    inherited;

    if comparetext(coin, 'tusd') =0 then begin
      //get current price of bitcoin
      csBTC.nao := 1/btx.GetConvertableRateAndValue('btc', 'tusd', btIAmBuying, 1.0, qtAlt, true).bestRate;

      //get 24-hour price of bitcoin
      csBTC.future :=enroyd.Get24HourBitCoinPrice;
      csCOIN.nao := csBTC.nao;
      csCOIN.Future := csBTC.future;
      result := csBTC.PercentRise;
    end else begin
      //get current price of bitcoin
      csBTC.nao := 1/btx.GetConvertableRateAndValue('btc', 'tusd', btIAmBuying, 1.0, qtAlt, true).bestRate;

      //get 24-hour price of bitcoin
      csBTC.future :=enroyd.Get24HourBitCoinPrice;

      //get 24-hour price
      csCoin.nao := btx.GetConvertableRateAndValue('btc', coin, btIAmSelling, 1.0, qtAlt, true).bestRate;
      csCoin.nao := csCoin.nao * csBTC.nao;
      csCoin.future := enroyd.Get24HourPrice(coin);
      result := csCoin.PercentRise;
    end;


  end;
begin
  Debug.Log(CLRE+'Pick to Watch.');
  hBTXMarkets := btx.GetMarketSummaries('BTC');

  hEnroydMarkets := enroyd.TryGetPredictions;
  if hEnroydMarkets = nil then
    exit;
  Debug.Log(CLRD+'Enroyd='+hEnroydMarkets.o.ToJson);

  hEnroydMarkets.o.Iterate_Filter(
    procedure (recordNode: TJSON; var bAccept: boolean)
    begin
      bAccept := comparetext(recordNode['Coin'].value,'BTC') = 0;
    end
  );

  //determine if it is an inverse market (only applies to TUSD, USDT)
  hEnroydMarkets.o.Iterate_CalculateField('Inverse',
    procedure (recordNode: TJSON; newNode: TJSON)
    begin
      if comparetext(recordNode['Coin'].value,'BTC') = 0 then begin
        newNode.value := true;
      end else begin
        newNode.value := false;
      end;
    end
  );
  hEnroydMarkets.o.Iterate_CalculateField('PriceCoin',
    procedure (recordNode: TJSON; newNode: TJSON)
    begin
      if recordNode['Inverse'].value then begin
        newNode.value := 'BTC';
      end else begin
        newNode.value := recordNode['Coin'].value;
      end;
    end
  );
  //calculate market names
  hEnroydMarkets.o.Iterate_CalculateField('BTXMarketName',
    procedure (recordNode: TJSON; newNode: TJSON)
    begin
      if comparetext(recordNode['Coin'].value,'BTC') = 0 then begin
        newNode.value := 'BTC-TUSD';
        recordNode['Coin'].value :=  'TUSD';
      end else begin
        newNode.value := 'BTC-'+recordNode['Coin'].value;
      end;
    end
  );



  Debug.Log(CLRD+'Enroyd After Calc='+hEnroydMarkets.o.ToJson);

  Fetch;
  ClearWatching;
  if hBTXMarkets = nil then
    exit;
  s := hBTXMarkets.o.ToJson;
  Debug.Log('BTX='+s);

  hMerged := JSONUnionOf(hEnroydMarkets.o, hBTXMarkets.o['result'], 'BTXMarketName', 'MarketName');
  Debug.Log(CLRE+'MergedMarkets='+hMerged.o.ToJSON);

  setlength(marketscores, hMerged.o.iCount);

  for t:= 0 to high(marketscores) do begin
    marketscores[t].coin := hMerged.o[t]['Coin'].AsString;
    marketscores[t].j := THolder<TJSON>.create;
    marketscores[t].j.o := TJSON.create;
    marketscores[t].j.o.FromString(hMerged.o[t].ToJson);
    marketscores[t].score := ScoreCoin(marketscores[t].coin);
    marketScores[t].Msg := 'Slope:'+sat(marketscores[t].score);
    ssdb.CoinStat('btc', hMerged.o[t]['PriceCoin'].AsString, 'TargetPriceUSD', sat(csCoin.future));
    ssdb.CoinStat('btc', hMerged.o[t]['PriceCoin'].AsString, 'PriceUSD', sat(csCoin.nao));
    ssdb.CoinStat('btc', hMerged.o[t]['PriceCoin'].AsString, 'BTCTargetPriceUSD', sat(csBTC.future));
    ssdb.CoinStat('btc', hMerged.o[t]['PriceCoin'].AsString, 'BTCPriceUSD', sat(csBTC.nao));
//    ssdb.CoinStat('btc', marketscores[t].coin, 'TargetPriceUSD', sat(csCoin.future));
//    ssdb.CoinStat('btc', marketscores[t].coin, 'PriceUSD', sat(csCoin.nao));
//    ssdb.CoinStat('btc', marketscores[t].coin, 'BTCTargetPriceUSD', sat(csBTC.future));
//    ssdb.CoinStat('btc', marketscores[t].coin, 'BTCPriceUSD', sat(csBTC.nao));


  end;

  SortMarketScores;
  for t:= 0 to high(marketscores) do begin
    marketScores[t].rank := t;
    WatchCoin(marketscores[t]);
  end;


{
  h.o['result'].Sorti('BaseVolume');
    lastWatchpicktime := tickcount.getticker;
    setlength(marketscores, h.o['result'].iCount);
//    socialRanks := ssdb.GetTopPerformersInMessageClass('social_points', 1);
    socialRanks := ssdb.GetTopPerformersInMessageClass('social_velocity', 0.025);

    banned := ssdb.GetBannedCoins;
    for t := 0 to high(marketscores) do begin
      marketscores[t].Init;
      marketscores[t].coin := h.o['result'][t]['MarketCurrency'].AsString;
      marketscores[t].banned := zpos(lowercase(marketscores[t].coin+'.'), lowercase(banned)) >=0;
      vari := socialranks.o.Lookup('marketcoin', marketscores[t].coin, 'logmessage');//<<--- determines RANK in social_velocity
      if vartype(vari) = varNull then
        marketscores[t].score := - 9999
      else
        marketscores[t].score := vari;

      if uppercase(marketscores[t].coin) = 'RLC' then
        Debug.Log('RLC '+ marketscores[t].coin);


      marketscores[t].delist := marketscores[t].banned;
    end;
    SortMarketScores;
    for t:= 0 to length(marketscores)-1 do begin
      marketscores[t].btxrank := t;
      marketscores[t].btxBottomRank:= (high(marketscores)-t);
    end;
//  end;


  t := 0;
  iToCreate := MAX_OPEN_TRADES - length(trades);

  while t< Length(marketscores) do begin
    if shutdown then
      exit;
//    Debug.Log('checking '+marketscores[t].coin);
//    if FindOpenPosition(marketscores[t].coin) = nil then begin
      pmc := GetMarketComparison(marketscores[t].coin);
      if pmc <> nil then
        if pmc.cryptopia.ask > 0 then
          marketscores[t].crossbumpPercent := (pmc.bittrex.ask-pmc.cryptopia.ask)/pmc.cryptopia.ask
        else
          marketscores[t].crossbumpPercent := 0;


      r := h.o['result'].FindSubKey('MarketCurrency', marketscores[t].coin)['Last'].value;
      l := h.o['result'].FindSubKey('MarketCurrency', marketscores[t].coin)['Low'].value;
      v := h.o['result'].FindSubKey('MarketCurrency', marketscores[t].coin)['High'].value-l;
      if v = 0 then
        tp := 0
      else
        tp := (r-l) / v;

//      if (tp < 0.80)//IF QUICK "trade position" check is < x% of volatile range then continue
//      and (tp >= 0.00)
//      then begin
//        marketscores[t].crossbumpPercent := bCrossBump;
        if (not (marketscores[t].banned))and (marketscores[t].btxRank < TOP_RANKS) then
          WatchCoin(marketscores[t]);
//      end;

//    end;
    inc(t);
    if t = (length(marketscores) div 1) then
      exit;
  end;
}
end;

procedure TPDTrades.PickToScanXX;
begin
  raise ECritical.create('unimplemented');
//TODO -cunimplemented: unimplemented block
end;



procedure TPDTrades.PickToScan_Arb;
begin


end;

procedure TPDTrades.PickTrades;
begin
  if strat=nil then
    raise Ecritical.create('strat is nil');
  strat.PickTrades;
end;


procedure TPDTrades.PromoteOpenTrades;
var
  h: IHolder<TSERowset>;
  js: TJSON;
  n: TJSON;
  t: ni;
  s: ni;
  c: ni;
begin
  try
  js := TJSON.Create;
  try
    h := THolder<TSERowSEt>.create;
    h.o := ssdb.GetOpenPositions(-1);
    c := h.o.IndexOfField('marketcoin');
    s := h.o.IndexOfField('state');

    for t:= 0 to h.o.RowCount-1 do begin
      if strtofloat(h.o.values[s,t]) = 20  then begin
        n := TJSON.create;
        try
          n.AddMember('Coin').value := h.o.Values[c,t];
          js.AddIndexed(n);
        finally
          n.free;
        end;
      end;
    end;


    SaveStringAsFile('\\192.168.101.26\coindata\buynow.js',  '{Updated: "'+formatdatetime('YYYY-MM-DD hh:nnampm',localtimetoGMT(now))+' GMT",Data: '+js.ToJson+'}');



  finally
    js.free;

  end;
  except
  end;


end;

procedure TPDTrades.PushTopSocialToWeb;
var
  h: IHolder<TSERowset>;
  js: TJSON;
  outer: TJson;
  n: TJSON;
  t: ni;
  f: ni;
  c: ni;
begin
  outer := TJSON.create;
  try
    try
      js := TJSON.Create;
      try
        h := ssdb.GetTopPerformersInMessageClass('social_velocity', 0.025);
        f := h.o.IndexOfField('logmessage');
        c := h.o.IndexOfField('marketcoin');
        for t:= 0 to h.o.RowCount-1 do begin
          if strtofloat(h.o.values[f,t]) > 1.0 then begin
            n := TJSON.create;
            try
              n.AddMember('Coin').value := h.o.Values[c,t];
              n.AddMember('Score').value := commaize((h.o.Values[f,t]-1.0)*10000);
              js.AddIndexed(n);
            finally
              n.free;
            end;
          end;
        end;

        outer.AddMember('Updated').value := formatdatetime('YYYY-MM-DD hh:nnampm',localtimetoGMT(now))+' GMT';
        outer.AddMemberJSON('Data', js.ToJson);

        SaveStringAsFile('\\192.168.101.26\coindata\topsocial.js',  outer.ToJson);
      finally
        js.free;
      end;

    finally
      outer.free;
    end;

  except
  end;


end;

procedure TPDTrades.PushTradeRecommendationsToWeb;
begin
  try
    PromoteOpenTrades;
    PushTopSocialToWeb;
  except
  end;
end;

procedure TPDTrades.RefreshClosedPositions;
begin
  closedpositions := ssdb.GetClosedPositions();

end;

procedure TPDTrades.RefreshCMCCoins;
begin
  cmc := btx.GetCMCCoins;


end;

procedure TPDTrades.RollUpSignalBatch;
var
  a: TArray<TStatRec>;
  sr: TStatRec;
  fm: TFlexiMath;
  cointables: TArray<string>;
  t: ni;
begin
  exit;
  ssdb := prov.Need(false);
  try
    cointables := ssdb.GetCoinStatTables('', 'pick');
    for t := 0 to High(cointables) do begin
      a := ssdb.GetStatsToRollUp(cointables);
      for sr in a do begin
        fm := TFlexiMath.create;
        try
          if sr.msg <> '' then begin
            try
              fm.FromQuickSave(sr.msg);
              RollUpSignals(fm, sr.id, sr.timestamp, sr.basecoin, sr.marketcoin);
            except
              ssdb.CoinStat(sr.basecoin, sr.marketcoin, sr.messageClass, '', sr.timestamp, sr.id);
            end;
          end else begin
            ssdb.CoinStat(sr.basecoin, sr.marketcoin, sr.messageClass, '', sr.timestamp, sr.id);
          end;
        finally
          fm.free;
        end;
      end;
    end;

  finally
    prov.NoNeed(ssdb);
  end;

end;

procedure TPDTrades.RollUpSignals(fm: TFlexiMath; id: int64; ts: TDateTime; cBase, cMarket: string);
var
  s: string;
  n1, n2: TJSON;
  ssdb: TshapeShiftDB;
  bs, ss: double;
  bid, ask: double;
  at: double;
  a: Tarray<int64>;
  jhOut: IHolder<TFlexiMath>;
begin
  ssdb := prov.Need(false);
  try
    try
      if fm.HasNode('Slippage_Buy') then begin
        n1 := fm.GetNode('Slippage_Buy.crav.BestRate');
        n2 := fm.GetNode('Slippage_Buy.crav.FinalRate');
        ask := n1.value;
        bs := n2.value-n1.value;
        n1 := fm.GetNode('Slippage_Sell.crav.BestRate');
        n2 := fm.GetNode('Slippage_Sell.crav.FinalRate');
        bid := n1.value;
        ss := n1.value-n2.value;
        if ss <> 0 then begin
          jhOut := THolder<TFlexiMath>.create;
          jhOUT.o := TFlexiMath.create;
          if fm.HasNode('ActionSignal') then
            jhOut.o.Add('ActionSignal', StrToJSONh(vartostr(fm.GetNode('ActionSignal').Value)))
          else
            jhOut.o.Add('ActionSignal', StrToJSONh(vartostr(0.0)));

          jhOut.o.Add('Signal', StrToJSONh(floattostr(bs/(bs+ss))));
          jhOut.o.Add('Bid', StrToJSONh(floattostr(bid)));
          jhOut.o.Add('Ask', StrToJSONh(floattostr(ask)));

          ssdb.CoinStat(cBase, cMarket, 'ChartCache', jhOut.o.tojson, ts, id,0);

        end;
      end else begin
        ssdb.CoinStat(cBase, cMarket, 'ChartCache', '', ts, id,0);
      end;
    except
    end;

  finally
    prov.noneed(ssdb);
  end;
end;

procedure TPDTrades.RollUpTrajectories(c: TCommand);
var
  ms: TMarketScore;
  t: ni;
begin
  for t:= 0 to high(marketScores)-1 do begin
    if assigned(c) and c.IsCancelled then
      exit;

    RollUpTrajectory('btc', marketscores[t].coin);
  end;
  RollupTrajectory('btc', '');

end;

procedure TPDTrades.RollUpTrajectory(sBase, sMarketCoin: string);
begin
  ssdb.RollUpTrajectory(sBase, sMarketCoin);
end;

procedure TPDTrades.Save;
begin

  raise ECritical.create('unimplemented');
//TODO -cunimplemented: unimplemented block
end;


procedure TPDTrades.SavePosition(p: TOpenPosition);
begin

  ssdb.SavePosition(p);

end;

procedure TPDTrades.SendSellMail(p: TOpenPosition);
var
  pp: TPositionProfits;
  s: string;
begin
  try
    SavePosition(p);
    ssdb.CoinLog('BTC', p.coin, 'getting position profits for '+p.coin);
    pp := ssdb.GetPositionProfits(p);
    ssdb.CoinLog('BTC', p.coin, 'profits {'+sat(pp.bought)+','+sat(pp.sold)+'}');
    if pp.percentprofits < 0 then begin
      s := 'sold '+pp.coin+' loss '+floatprecision((0-pp.PercentProfits)*100, 2)+'% because:'+p.because;
      ssdb.CoinLog('BTC', p.coin, s);
      if ssdb.accountid = 1 then begin
        CoinMail(s);
      end;
    end
    else begin
      s := 'sold '+pp.coin+' profit '+floatprecision((pp.PercentProfits)*100, 2)+'%  because:'+p.because;
      //CoinMail('sold '+pp.coin+' for profit of '+floatprecision(pp.PercentProfits*100, 2)+'%.. BTCVal='+sat(btx.AvailableFunds['btc'].Amount));
      ssdb.CoinLog('BTC', p.coin, s);
      CoinMail(s);
    end;
  except
  end;

end;

procedure TPDTrades.SortMarketScores;
var
  bDone: boolean;
  t: ni;
  procedure Swap(i1,i2: ni);
  var
    js: TMarketScore;
  begin
    js := marketscores[i1];
    marketscores[i1] := marketscores[i2];
    marketscores[i2] := js;
  end;
const
  bDesc = true;
begin
  bDone := false;
  while not bDone do begin
    bDone := true;
    for t:= 0 to length(marketscores)-2 do begin
      if bDesc then begin
        if marketscores[t].score < marketscores[t+1].score then begin
          Swap(t,t+1);
          bDone := false;
        end;
      end else begin
        if marketscores[t].score > marketscores[t+1].score then begin
          Swap(t,t+1);
          bDone := false;
        end;
      end;
    end;
  end;

  Debug.Log('Sorted Markets:');
  for t:= 0 to length(marketscores)-1 do begin
    marketscores[t].rank := t;
    marketscores[t].BottomRank:= (high(marketscores)-t);
    Debug.Log('#'+t.tostring+' '+marketscores[t].coin+' Score:'+marketscores[t].score.tostring);
  end;

end;

function TPDTrades.TimeToPickTrade: boolean;
begin
  if lastTradePickTime = 0 then
    exit(true);
  result := GetTimeSince(lastTradePickTime) > 30000;

end;

function TPDTrades.TimeToPickWatch: boolean;
begin
  if lastWatchPickTime = 0 then
    exit(true);
  result := GetTimeSince(lastWatchPickTime) > 1000*60*60;
end;

procedure TPDTrades.TryFixSocialVelocity(coin: string);
var
  cs: TCoinStat;
begin
  exit;
  cs := ssdb.GetCoinStatPeak(coin, 'fix_level', 0.001,now());
  if cs.val <> '' then begin
    if strtofloat(cs.val) < 0.5 then begin
      ssdb.CoinStat('BTC', coin, 'fix_level', '0.5', now());
      FixSocialVelocity(coin);
      ssdb.CoinStat('BTC', coin, 'fix_level', '1.0', now());
    end;
  end;
end;

procedure TPDTrades.Tweet(msg: string);
var
  tw: TTwitterClient;
  h: IHolder<TJSON>;
  t: ni;
begin
  if not APGEt('enable_twitter', false) then
    exit;

  tw := TTwitterEvilRobot.create;
  try
    try
      h := tw.Tweet(msg);
    except
    end;
  finally
    tw.free;
  end;
end;

function TPDTrades.TYPICAL_OPEN_TRADES: double;
begin
  result := (btx.totalFundsValue/1) / 0.0015000;
  if result = 0 then
    result := DEFAULT_TYPICAL_OPEN_TRADES;

  result := lesserof(DEFAULT_TYPICAL_OPEN_TRADES, result);//200/3 because 1/3rd are low, 1/3rd holding, 1/3rd are too high, * 7 because a 30-day low is about 7-times as long as a 2 day high

end;

procedure TPDTrades.UpdateFundValue;
begin
  btx.RefreshFunds;
  fundValue := btx.totalFundsValue;
  ssdb.RecordFundValue(fundValue);

end;

procedure TPDTrades.WatchCoin(ms: TMarketScore);
begin
  lock;
  try
    if comparetext(ms.coin,'btc')=0 then
      exit;
    if ms.delist then
      exit;
    setlength(watching, length(watching)+1);
    //btx.GetChartAnalysis('BTC', ms.coin, cp1);
    ms.scantime := 0;
    watching[high(watching)] := ms;


  finally
    unlock;
  end;
end;

{ TOpenPosition }



{ TMarketScore }

procedure TMarketScore.Init;
begin
  coin := '';
  delist := false;
  banned := false;
end;

function TMarketScore.RefreshRate: ni;
begin
  result := round(greaterof(900000/(checkpoints+1),10000.0));
end;

procedure TMarketScore.SetMessage(Value: string);
var
  s: string;
  t: ni;
begin
  Debug.Log('TMarketScore', pointer(@self), 'Set Message '+value);
  s := '[';
  for t:= 1 to passed do
    s := s + '|';
  for t := passed to checkpoints do begin
    s := s + '.';
  end;
  s := s + ']';


  FMsg := s+' '+Value;

  Debug.Log(s+' '+coin+': '+value);
end;

{ TBittrexWatcher }

procedure TBittrexWatcher.Detach;
begin
  if detached then
    exit;
  if assigned(cmd) then
    cmd.waitfor;
  cmd.free;
  cmd := nil;

  pdTrades.Free;
  pdTrades := nil;

  inherited;
end;

procedure TBittrexWatcher.DoExecute;
begin
  inherited;

  try
    RunHot := false;
    ColdRunInterval := 1000;

    if GetTimeSInce(lastWebPush) > 300000 then begin
      pdTrades.PushTradeRecommendationsToWeb;
      lastwebpush := getticker;
    end;

    if aPositionChanged then begin
      //pdTrades.btx.RefreshFunds;
      apositionChanged := false;
    end;

    aPositionChanged := pdTrades.CheckPositions(LiquidateToBTC, self);//<---------

{$IFDEF USE_SENTINEL}
    if cmd = nil then begin
      if ((pdTrades.closed>0) or pdTrades.TimeToPickTrade) and (length(pdTrades.trades) <  MAX_OPEN_TRADES) then begin
        if pdTrades.TimeToPickTrade and (bgcmd.commandcount = 0) then begin
          try
              Status := 'Create new market sentinel';
//            if (pdTrades.moons = 0) then begin//NEVER PICK NEW TRADES WHEN MOONING!
              cmd := TMarketSentinel.create;
              cmd.pd.strat.forcedPosition := self.pdTrades.strat.forcedPosition;
              cmd.pd.allowNewPositions := self.pdTrades.allowNewPositions;
              if pdTrades.TimeToPickWatch then begin
                cmd.PickNewToWatch := true;
                pdTrades.lastWatchPickTime := getticker;
              end;
              lock;
              try
                cmd.GivePreviousResults(pdTrades.marketScores, pdTrades.watching);
              finally
                unlock;
              end;
              cmd.Start;
//            end;

          except
            on E: Exception do begin
              Debug.Log('Pick Watch failed: '+e.message);
            end;
          end;
        end;
      end;
    end else begin
      if cmd.IsComplete then begin
        Status := 'Complete market sentinel';
        pdTrades.lastTradePickTime := getticker;
        cmd.GetResults(pdtrades.marketScores, pdTrades.watching);
        self.marketsUpdated := true;
        self.pdTrades.dropBags := cmd.pd.dropBags or self.pdTrades.dropBags;
        self.pdTrades.btcMoon := cmd.pd.btcmoon;
        self.pdTrades.climateAssessment := cmd.pd.climateAssessment;
        self.pdTrades.bitcoinClimate := cmd.pd.bitcoinClimate;
        cmd.pd.dropbags := false;

        cmd.free;
        cmd := nil;
      end;
    end;
{$ELSE}
    if pdTrades.TimeToPickTrade then begin
      pdTrades.lastTradePickTime := getticker;
      pdTrades.PickTrades;
    end;
{$ENDIF}


    if LiquidateToBTC and (length(pdTrades.trades)=0) then begin
      pdTrades.LiquidateDust;
      LiquidateToBTC := false;
    end;
    if apositionChanged then
      PositionsUpdated := true;


    if (lastValuecheck = 0) or (getTimeSince(lastValueCheck) > 600000) then begin
      Status := 'Update Fund Value';
      pdtrades.UpdateFundValue;
      lastValueCheck := getticker;
    end;
    fundValue := pdTrades.fundValue;

  except
    on E: Exception do begin
      Debug.Log('Watcher Error: '+e.message);
    end;
  end;
end;

function TBittrexWatcher.GetUpdatedMarketScores(
  var a: TArray<TMarketScore>): boolean;
var
  t: ni;
begin
  result := MarketsUpdated;
  if MarketsUpdated then begin

    pdTrades.Lock;
    try
      setlength(a, length(pdTrades.marketscores));
      for t:= 0 to high(a) do
        a[t] := pdTrades.marketScores[t];
    finally
      pdTrades.Unlock;
    end;
  end;

  MarketsUpdated := false;


end;

function TBittrexWatcher.GetUpdatedPositions(
  var a: TOpenPositionArray): boolean;

var
  t: ni;
  bDone: boolean;
  procedure Swap(i1,i2: ni);
  var
    js: TOpenPosition;
  begin
    js := a[i1];
    a[i1] := a[i2];
    a[i2] := js;
  end;
begin
  result := PositionsUpdated;
  if PositionsUpdated then begin
    pdTrades.Lock;
    try
      setlength(a, length(pdTrades.trades));
      for t:= 0 to high(a) do
        a[t] := pdTrades.trades[t];

      bDone := false;
      while not bDone do begin
        bDone := true;
        for t:= 0 to high(a)-1 do
          if a[t].state > a[t+1].state then begin
            Swap(t,t+1);
            bDone := false;
          end else begin
            if a[t].state = a[t+1].state then begin
              if a[t].ProfitPercent < a[t+1].ProfitPercent then begin
                Swap(t,t+1);
                bDone := false;
              end;
            end;
          end;

      end;

    finally
      pdTrades.Unlock;
    end;
  end;

  PositionsUpdated := false;

end;

function TBittrexWatcher.GetUpdatedWatchers(
  var a: TArray<TMarketScore>): boolean;
var
  t: ni;
begin
  result := MarketsUpdated;
  if MarketsUpdated then begin

    pdTrades.Lock;
    try
      setlength(a, length(pdTrades.watching));
      for t:= 0 to high(a) do
        a[t] := pdTrades.watching[t];
    finally
      pdTrades.Unlock;
    end;
  end;

  MarketsUpdated := false;


end;

procedure TBittrexWatcher.Init;
begin
  inherited;
//  icon := @cmd_icon_watcher;
  pdtrades := TPDTrades.create;
  pdTrades.AllowTrades := true;
  pdTrades.AllowDBupdates := true;

  aPositionChanged := true;


end;

procedure TBittrexWatcher.OnFinish;
begin
  if assigned(cmd) then begin
    cmd.WaitFor;
    cmd.free;
    cmd := nil;
  end;
  inherited;

end;

{ TMarketSentinel }

procedure TMarketSentinel.Detach;
begin
  if detached then exit;
  if assigned(cmd_Traj) then begin
    cmd_Traj.cancel;
    cmd_Traj.waitfor;
    cmd_Traj.free;
    cmd_traj := nil;
  end;
  pd.Free;
  pd:= nil;

  inherited;
end;

procedure TMarketSentinel.DoExecute;
begin
  inherited;
  pd.PicktoScan;
  FRaiseExceptions := false;
  if PickNewToWatch then begin
    if assigned(cmd_Traj) then begin
      if cmd_Traj.IsComplete then begin
        cmd_Traj.free;
        cmd_Traj := nil;
      end;
    end;
    if not assigned(cmd_Traj) then begin
      cmd_Traj := Tcmd_RollupTrajectories.create;
      cmd_Traj.start;
    end;
    pd.PushTradeRecommendationsToWeb;
//    pd.PickToWatch;
  end;
  pd.PickTrades;


end;

function TMarketSentinel.GetResults(var a: TArray<TMarketScore>; var w: TArray<TMarketScore>): boolean;
var
  t: ni;
begin
  result := false;
  pd.Lock;
  try
    setlength(a, length(pd.marketscores));
    for t:= 0 to high(a) do
      a[t] := pd.marketScores[t];

    setlength(w, length(pd.watching));
    for t:= 0 to high(w) do
      w[t] := pd.watching[t];
  finally
    pd.Unlock;
  end;

end;

procedure TMarketSentinel.GivePreviousResults(a: TArray<TMarketScore>; w: TArray<TMarketScore>);
var
  t: ni;
begin
  setlength(pd.previousmarketScores, length(a));
  for t:= 0 to high(pd.previousmarketScores) do
    pd.previousmarketScores[t] := a[t];

  setlength(pd.watching, length(w));
  for t:= 0 to high(pd.watching) do
    pd.watching[t] := w[t];



end;

procedure TMarketSentinel.Init;
begin
  inherited;
  icon := @CMD_ICON_SENTINEL;
  pd := TPDTrades.create;
  pd.AllowTrades := true;

end;

{ TForcedPosition }

procedure TForcedPosition.init;
begin
  enable := true;
  base := 'btc';
  market := 'ltc';
  risk := 0.005;


end;



{ TManageStrategy }

procedure TStrategyCommand.Detach;
begin
  if detached then
    exit;
  fm.free;
  fm := nil;

  pdTrades.free;
  pdTrades := nil;

  inherited;

end;

procedure TManageStrategy.DoExecute;
begin
  inherited;

end;

procedure TStrategyCommand.DoExecute;
begin
  inherited;
  new;
end;


procedure TStrategyCommand.Init;
begin
  inherited;
  fm := TFlexiMath.create;
  pdTrades := TPDTrades.create;
end;

procedure TStrategyCommand.New;
begin
{$IFDEF PERSIST_COMMANDS}
  fm.free;
  fm := TFlexiMath.create;
{$ENDIF}
end;

procedure TStrategyCommand.StratStatus(s: string);
begin
  status := s;
end;

procedure TManageStrategy.Init;
begin
  inherited;
  icon := @CMD_ICON_MANAGE;
end;

procedure TManageStrategy.InitExpense;
begin
  inherited;
  CPUExpense := 0.1;
  Resources.SetResourceUsage('btxEssential', 0.1);
end;

procedure TManageStrategy.StratStatus(s: string);
begin
  status := p.tradename+' '+s;
end;

{ TPickStrategy }

procedure TPickStrategy.DoExecute;
begin
  inherited;

end;



procedure TPickStrategy.Init;
begin
  inherited;
  icon := @CMD_ICON_PICK;
end;

procedure TPickStrategy.InitExpense;
begin
  inherited;
  CPuExpense := 0.01;
  Resources.SetResourceUsage('btxNonEssentual', 0.12);
end;

procedure TPickStrategy.StratStatus(s: string);
begin
  status := ms.coin+': '+s;
end;

{ Tcmd_RollupTrajectories }

procedure Tcmd_RollupTrajectories.Detach;
begin
  pd.Free;
  pd:= nil;

  inherited;

end;

procedure Tcmd_RollupTrajectories.DoExecute;
begin
  inherited;

  exit;
  RaiseExceptions := false;
  pd.PickToScan;
  pd.RollUpTrajectories(self);





end;

procedure Tcmd_RollupTrajectories.Init;
begin
  inherited;
  pd := TPDTrades.create;
  pd.AllowTrades := true;
  self.RaiseExceptions := false;
  icon := @CMD_ICON_ROLLUP;

end;

procedure oinit;
begin
  cacheLocks := TNamedRWLocks.Create;
  forcedirectories(dllpath+'\quotes');
  GJSONCache := TJSONCache.Create;
  ManageProcesssor := TCommandProcessor.create(nil, 'Pick Commands');

end;

procedure ofinal;
begin

  ManageProcesssor.free;
  ManageProcesssor := nil;
  GJSONCache.free;
  GJSONCache := nil;
  cacheLocks.free;
  cacheLocks := nil;
end;

{ Tcmd_ChartToStats }

procedure Tcmd_ChartToStats.DoExecute;
var
  pd: TpdTrades;
begin
  inherited;
  if exchange = '' then
    raise Ecritical.create('set exchange!');
  pd := nil;
  try
    pd := TpdTrades.create;
    pd.ssdb.ChartUpdate(cd, true);
//    pd.ChartToStats(exchange, c,  BGCmd.CommandCount > 300);
  finally
    pd.free;
  end;


end;

procedure Tcmd_ChartToStats.InitExpense;
begin
  inherited;
  resources.SetResourceUsage('ChartUpdate', 1.0);

end;

{ Tcmd_GetChartAndPush }

procedure Tcmd_GetChartAndPush.DoExecute;
var
  pd: TpdTrades;
  c: TChartAnalysis;
  cmd: Tcmd_ChartToStats;
begin
  inherited;
  pd := nil;
  try
    pd := TpdTrades.create;
    c := pd.btx.GetChartAnalysis(basecoin, marketcoin, period);
    c.Calc(calcPeriods);
  finally
    pd.free;
  end;
  if length(c.a) > 0 then begin
    cmd := Tcmd_ChartToStats.Create;
    cmd.cd := c.a;
    cmd.FireForget := true;
    cmd.Start;
  end else begin
    Debug.Log('GetChartAnalysis still does not have array data');
  end;
end;

procedure Tcmd_GetChartAndPush.InitExpense;
begin
  inherited;
  resources.SetResourceUsage('ChartUpdate', 1.0);
end;

{ TCoinSlope }

function TCoinSlope.PercentRise: double;
begin
  result :=  (future/nao - 1.0);
end;

initialization

init.RegisterProcs('ProblemDomain', oinit, ofinal, 'CommandProcessor,ManagedThread');
GDebugPositionID := 0;


finalization


end.
